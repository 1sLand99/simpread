> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.ibm.com](https://www.ibm.com/think/x-force/reproducing-million-dollar-bug-whatsapp-cve-2019-11932-afl-frida)

> Dive into research on a double-free vulnerability, CVE-2019-11932, in an image processing library use......

Authors
-------

Ruben Boonen

CNE Capability Lead, Adversary Services

IBM X-Force

Introduction
------------

This post is partially an analysis of a double-free vulnerability (_CVE-2019-11932_) in an image processing library used by WhatsApp and partially a reference for on-device harness development when fuzzing native libraries on Android. I first learned of this vulnerability by reading a [blog post](https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/) from _Awakened_, the researcher who disclosed the issue. The author did not elaborate on how this issue was found, and I wanted to understand how hard it would be to rediscover the bug. As we will see, the vulnerability itself is fairly shallow and is easy to reproduce by fuzzing the vulnerable library with AFL++.

This CVE is particularly interesting because the vulnerable library code ([_android-gif-drawable_](https://github.com/koral--/android-gif-drawable) < _v1.2.18_) could be triggered remotely by sending someone a malformed GIF file. This primitive was not perfect as it relied on the target taking some manual actions, like opening the WhatsApp image gallery. Additionally, this vulnerability would only be part of a larger component chain that would include additional vulnerabilities, for example, to perform information leaks and to escalate privileges. Still, these types of vulnerabilities are rare and expensive because of the potential human intelligence value they provide. This case also illustrates why it is so important that applications audit the libraries they include in their code base. Large enterprises should perhaps do more to contribute to and improve the security of Open-Source Software (OSS) they employ in their products. A more recent, analogous example resulted in the disclosure of [five vulnerabilities](https://www.openwall.com/lists/oss-security/2025/06/16/6) in _libxml2_.  

CVE-2019-11932 root cause analysis (RCA)
----------------------------------------

Based on _Awakened_’s vulnerability writeup, I focused my efforts on the GIF decoding routine. A GIF file is structured as a header and logical screen descriptor followed by a stream of records for each frame. These records consist of an image descriptor (width, height, position and palette), optional extension blocks (transparency, delays, etc), and compressed pixel data. In _decoding.c_ there is a function, _DDGifSlurp_, which walks the GIF record streams and builds up per-frame metadata. If _decode=true_, it extracts raw per-frame pixels. Normally, frames are the same size. This makes sense because when you look at a GIF, you see a series of frames playing in a loop. When frames are the same size, the function will keep reusing the allocation it has created to store the buffer (_rasterBits_). However, the function does handle cases where the frames are of a different size by calling _reallocarray_ to allocate a new buffer. The _realloc_ function is a combination of _free_ and _malloc._ If no size is provided, it simply frees the pointer.

Commit _df309bb - decoding.c_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/decoding.c#L17)

**void** DDGifSlurp(GifInfo *****info, **bool** decode, **bool** exitAfterFrame) {  
    GifRecordType RecordType;  
    GifByteType *****ExtData;  
    **int** ExtFunction;  
    GifFileType *****gifFilePtr;  
    gifFilePtr = info->gifFilePtr;  
    **uint_fast32_t** lastAllocatedGCBIndex = 0;  
...  
if (decode) {  
    **int_fast32_t** widthOverflow = gifFilePtr->Image.Width - info->originalWidth;  
    **int_fast32_t** heightOverflow = gifFilePtr->Image.Height - info->originalHeight;  
    **const** **uint_fast32_t** newRasterSize = gifFilePtr->Image.Width * gifFilePtr-  
->Image.Height;  
    if (newRasterSize> info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {  
        **void** *****tmpRasterBits = reallocarray(info->rasterBits, newRasterSize,  
sizeof(GifPixelType));  
        if (tmpRasterBits == NULL) {  
            gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;  
            break;  
        }  
        info->rasterBits = tmpRasterBits;  
        info->rasterSize = newRasterSize;  
    }  
...

If we imagine the first frame has some normal dimensions,_40*10_, a buffer of _400_ bytes is allocated. The second frame has some malformed dimensions, _0*20._ In this case, the following is true:

*   _widthOverflow_ is _false_
*   _heightOverflow_ is _true_
*   _newRasterSize_ is _0_

When _reallocarray_ is called, the allocation size is calculated as _0*20=0;_ this causes _rasterBits_ to be _free'd_. If the third frame has similarly malformed dimensions, it _free_s the same pointer again, resulting in a _double-free_.

android-gif-drawable
--------------------

### Symbols

Symbols are important; they make it easier to interpret what a piece of code is doing. If you analyze libraries that were extracted from an Android Package Kit (APK), they will most likely be stripped of symbols. In our particular case, for _android-gif-drawable_, this is not an issue because we have access to the source. However, if you need to reverse engineer a closed-source binary, you should at least apply the Java Native Interface (_JNI_) types to make the research process more straightforward. There is a post by [_@Ch0pin_](https://x.com/Ch0pin) you can read [_here_](https://valsamaras.medium.com/tracing-jni-functions-75b04bee7c58) to give you some more background. In my case, I am using _Binary Ninja,_ and I found a working type header file that can be imported [_here_](https://github.com/Ayrx/binja-typelibs-collection/blob/master/sources/jni_binja.h).

To understand how to apply the types, you can search the decompiled APK for native declarations. In the screenshot below, we can see some of the _android-gif-drawable_ declarations from the APK in JEB.

Take _getFrameDuration_ as an example:

.method public **static** native getFrameDuration(J, I)I  
.end method

Here, _J_ translates to _jlong_ and _I_ translates to _jint_. Notice that the function also has a return type of _jint_. If we combine these values with the standard calling convention for native JNI invocation, we end up with:

jint getFrameDuration(JNIEnv* env, jclass clazz, jlong arg0, jint arg1)

You can apply some automation to this process (using [_androguard_,](https://github.com/androguard/androguard) JEB API, etc). With proper type mappings you can programmatically walk every class and apply all identified types to the library you are analyzing.

Some engineering is required to parse the APK, extract the call definitions and apply them in your preferred decompiler. This effort is worth it because it reduces the amount of manual labor, and it can give you a high-level overview of native library use in the APK as a whole.

 ![](https://www.ibm.com/content/dam/connectedassets-adobe-cms/worldwide-content/pm/ul/g/cb/1c/23_11_p-028_1200x1200.component.think-ad-xl.ts=1734532003827.jpeg/content/experience-fragments/adobe-cms/us/en/site-v2/think-hub/article/_8_column_general_ad/blueprint---think-ad---xf---do-not-modify/cybersecurity-thinkad-article-newsletter/_jcr_content/root/think_ad_copy/image) 

### Strengthen your security intelligence  

Stay ahead of threats with news and insights on security, AI and more, weekly in the Think Newsletter.  

[Subscribe today](https://www.ibm.com/account/reg/signup?formid=news-urx-52954)

### Fuzzing DDGifSlurp

### _How can we reach our target function?_

The first thing I did (since the library is open-source) was build my own version of _android-gif-drawable_ from the [_v1.2.17_](https://github.com/koral--/android-gif-drawable/releases/tag/v1.2.17) release package using the _Android NDK_. Then, I reviewed what exports were available in the binary:

➜ nm -D lib/libpl_droidsonroids_gif_fixed.so | awk '$3 ~ /^D/ || $3 ~ /^Java_pl_/'  
 0000000000006214 T DDGifSlurp  
 000000000000ad14 T DGifCloseFile  
 000000000000ac58 T DGifExtensionToGCB  
 000000000000a91c T DGifGetCodeNext  
 000000000000aa68 T DGifGetExtension  
 000000000000ab20 T DGifGetExtensionNext  
 0000000000009cc0 T DGifGetImageDesc  
 000000000000a254 T DGifGetLine  
 0000000000009b98 T DGifGetRecordType  
 000000000000989c T DGifGetScreenDesc  
 0000000000009644 T DGifOpen  
 000000000000bb90 T DetachCurrentThread  
 000000000000d53c T Java_pl_droidsonroids_gif_GifInfoHandle_bindSurface  
 0000000000009314 T  
Java_pl_droidsonroids_gif_GifInfoHandle_createTempNativeFileDescriptor  
 00000000000091ac T  
Java_pl_droidsonroids_gif_GifInfoHandle_extractNativeFileDescriptor  
 0000000000006d20 T Java_pl_droidsonroids_gif_GifInfoHandle_free  
 000000000000c238 T Java_pl_droidsonroids_gif_GifInfoHandle_getAllocationByteCount  
 000000000000bd74 T Java_pl_droidsonroids_gif_GifInfoHandle_getComment  
 000000000000c578 T Java_pl_droidsonroids_gif_GifInfoHandle_getCurrentFrameIndex  
 000000000000c528 T Java_pl_droidsonroids_gif_GifInfoHandle_getCurrentLoop  
 000000000000c008 T Java_pl_droidsonroids_gif_GifInfoHandle_getCurrentPosition  
 000000000000bf00 T Java_pl_droidsonroids_gif_GifInfoHandle_getDuration  
 000000000000caa4 T Java_pl_droidsonroids_gif_GifInfoHandle_getFrameDuration  
 000000000000cbc0 T Java_pl_droidsonroids_gif_GifInfoHandle_getHeight  
 000000000000be68 T Java_pl_droidsonroids_gif_GifInfoHandle_getLoopCount  
 000000000000c15c T Java_pl_droidsonroids_gif_GifInfoHandle_getMetadataByteCount  
 000000000000c4d4 T Java_pl_droidsonroids_gif_GifInfoHandle_getNativeErrorCode  
 000000000000cc14 T Java_pl_droidsonroids_gif_GifInfoHandle_getNumberOfFrames  
 000000000000c5cc T Java_pl_droidsonroids_gif_GifInfoHandle_getSavedState  
 000000000000bfb4 T Java_pl_droidsonroids_gif_GifInfoHandle_getSourceLength  
 000000000000cb6c T Java_pl_droidsonroids_gif_GifInfoHandle_getWidth  
 000000000000cc68 T Java_pl_droidsonroids_gif_GifInfoHandle_glTexImage2D  
 000000000000cd50 T Java_pl_droidsonroids_gif_GifInfoHandle_glTexSubImage2D  
 000000000000ce38 T Java_pl_droidsonroids_gif_GifInfoHandle_initTexImageDescriptor  
 000000000000bde4 T Java_pl_droidsonroids_gif_GifInfoHandle_isAnimationCompleted  
 000000000000cb10 T Java_pl_droidsonroids_gif_GifInfoHandle_isOpaque  
 00000000000084cc T Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray  
 00000000000087a4 T Java_pl_droidsonroids_gif_GifInfoHandle_openDirectByteBuffer  
 0000000000008278 T Java_pl_droidsonroids_gif_GifInfoHandle_openFile  
 0000000000009340 T Java_pl_droidsonroids_gif_GifInfoHandle_openNativeFileDescriptor  
 0000000000008ab8 T Java_pl_droidsonroids_gif_GifInfoHandle_openStream  
 000000000000e354 T Java_pl_droidsonroids_gif_GifInfoHandle_postUnbindSurface  
 00000000000057dc T Java_pl_droidsonroids_gif_GifInfoHandle_renderFrame  
 000000000000597c T Java_pl_droidsonroids_gif_GifInfoHandle_reset  
 000000000000611c T Java_pl_droidsonroids_gif_GifInfoHandle_restoreRemainder  
 000000000000c9d8 T Java_pl_droidsonroids_gif_GifInfoHandle_restoreSavedState  
 000000000000603c T Java_pl_droidsonroids_gif_GifInfoHandle_saveRemainder  
 0000000000005f6c T Java_pl_droidsonroids_gif_GifInfoHandle_seekToFrame  
 000000000000d4d0 T Java_pl_droidsonroids_gif_GifInfoHandle_seekToFrameGL  
 0000000000005ccc T Java_pl_droidsonroids_gif_GifInfoHandle_seekToTime  
 000000000000beb8 T Java_pl_droidsonroids_gif_GifInfoHandle_setLoopCount  
 000000000000b948 T Java_pl_droidsonroids_gif_GifInfoHandle_setOptions  
 00000000000059e4 T Java_pl_droidsonroids_gif_GifInfoHandle_setSpeedFactor  
 000000000000cfa0 T Java_pl_droidsonroids_gif_GifInfoHandle_startDecoderThread  
 000000000000d374 T Java_pl_droidsonroids_gif_GifInfoHandle_stopDecoderThread

This is helpful information because we know we can call _DDGifSlurp_ directly, and we can also see the set of JNI-exported functions. If we look at _DDGifSlurp_ again, we see that the first argument is a pointer to some complex type, _GifInfo_.

**void** DDGifSlurp(GifInfo *****info, **bool** decode, **bool** exitAfterFrame)

Commit _df309bb - gif.h_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/gif.h#L90)

**struct** GifInfo {  
    **void** (*destructor)(GifInfo *****, JNIEnv *****);  
    GifFileType *****gifFilePtr;  
    GifWord originalWidth, originalHeight;  
    **uint_fast16_t** sampleSize;  
    **long** **long** lastFrameRemainder;  
    **long** **long** nextStartTime;  
    **uint_fast32_t** currentIndex;  
    GraphicsControlBlock *****controlBlock;  
    argb *****backupPtr;  
    **long** **long** startPos;  
    **unsigned** **char** *****rasterBits;  
    **uint_fast32_t** rasterSize;  
    **char** *****comment;  
    **uint_fast16_t** loopCount;  
    **uint_fast16_t** currentLoop;  
    RewindFunc rewindFunction;  
    jfloat speedFactor;  
    **uint32_t** stride;  
    jlong sourceLength;  
    **bool** isOpaque;  
    **void** *****frameBufferDescriptor;  
};

We could manually create a fake _GifInfo_ object; however, the object is quite big and is itself a composite of other complex types (like _GifFileType_). Instead, it makes more sense to investigate the other native functions to see how _GifInfo_ objects are usually created. We can quickly find some potential candidates.

Commit _df309bb - gif.c_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/gif.c#L135)

Java_pl_droidsonroids_gif_GifInfoHandle_openFile  
Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray  
Java_pl_droidsonroids_gif_GifInfoHandle_openDirectByteBuffer  
Java_pl_droidsonroids_gif_GifInfoHandle_openStream

Of these, the byte variants seem to have the least overhead; in particular, _openByteArray_ only requires us to create a _jbyteArray_ object, which we can do easily in C.

__unused JNIEXPORT jlong JNICALL  
Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray(JNIEnv *env, jclass __unused  
class, jbyteArray bytes) {  
    if (isSourceNull(bytes, env)) {  
        return NULL_GIF_INFO;  
    }  
    ByteArrayContainer *container = malloc(sizeof(ByteArrayContainer));  
    if (container == NULL) {  
        throwException(env, OUT_OF_MEMORY_ERROR, OOME_MESSAGE);  
        return NULL_GIF_INFO;  
    }  
    container->buffer = (*env)->NewGlobalRef(env, bytes);  
    if (container->buffer == NULL) {  
        free(container);  
        throwException(env, RUNTIME_EXCEPTION_BARE, "NewGlobalRef failed");  
        return NULL_GIF_INFO;  
    }  
    container->length = (**unsigned** **int**) (*env)->GetArrayLength(env, container->buffer);  
    container->position = 0;  
    GifSourceDescriptor descriptor = {  
            .rewindFunc = byteArrayRewind,  
            .sourceLength = container->length  
    };  
    descriptor.GifFileIn = DGifOpen(container, &byteArrayRead, &descriptor.Error);  
    descriptor.startPos = container->position;  
    GifInfo *info = createGifInfo(&descriptor, env);  
    if (info == NULL) {  
        (*env)->DeleteGlobalRef(env, container->buffer);  
        free(container);  
    }  
    return (jlong) (**intptr_t**) info;  
}

Note that the _GifInfo_ object itself is created by _createGifInfo_.

Commit _df309bb - init.c_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/init.c#L3)

GifInfo *createGifInfo(GifSourceDescriptor *descriptor, JNIEnv *env) {  
    if (descriptor->startPos < 0) {  
        descriptor->Error = D_GIF_ERR_NOT_READABLE;  
    }  
    if (descriptor->Error != 0 || descriptor->GifFileIn == NULL) {  
        **bool** readErrno = descriptor->rewindFunc == fileRewind && (descriptor->Error ==  
D_GIF_ERR_NOT_READABLE || descriptor->Error == D_GIF_ERR_READ_FAILED);  
        throwGifIOException(descriptor->Error, env, readErrno);  
        DGifCloseFile(descriptor->GifFileIn);  
        return NULL;  
    }  
    GifInfo *info = malloc(sizeof(GifInfo));  
...  
    DDGifSlurp(info, false, false);  
    info->rasterBits = NULL;  
    info->rasterSize = 0;  
    info->originalHeight = info->gifFilePtr->SHeight;  
    info->originalWidth = info->gifFilePtr->SWidth;  
...

In the above code snippet, you can see that the initialization function also calls _DDGifSlurp,_ but it is not able to trigger the vulnerable code because _decode=false_. Setting this flag to false triggers the _isInitialPass_ case within _DDGifSlurp,_ which only records per-frame metadata without parsing the frames.

At this point, we have a pretty good understanding of how to call the vulnerable code path, and we can put together a series of calls to reach the function we want to fuzz.

Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray  
   |_ DDGifSlurp

However, we are missing two elements here. First, if we create thousands of these call chains, we will run out of memory and crash our harness, so we need to make sure to _free_ any resources we create. To achieve this, we can use another of the JNI-exported functions.

Commit _df309bb - dispose.c_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/dispose.c#L4)

Java_pl_droidsonroids_gif_GifInfoHandle_free(JNIEnv *env, jclass __unused handleClass, jlong gifInfo)

The second missing element is much less obvious. When _DDGifSlurp_ initializes the GIF, it walks the list of frames, modifying the _GifInfo_ object as it goes. Before we can process the GIF again, we need to _rewind_ it to its initial state. Doing so resets our position in the _ByteArrayContainer_ to the start position and resets some properties of the _GifInfo_ object, as can be seen below.

Commit _df309bb - controle.c_ [_here_](https://github.com/koral--/android-gif-drawable/blob/df309bbe62a0599517cc9e09e7f00e5438e05f58/android-gif-drawable/src/main/c/control.c#L3)

**bool** reset(GifInfo *info) {  
    if (info->rewindFunction(info) != 0) {  
        return false;  
    }  
    info->nextStartTime = 0;  
    info->currentLoop = 0;  
    info->currentIndex = 0;  
    info->lastFrameRemainder = -1;  
    return true;  
}  
__unused JNIEXPORT jboolean JNICALL  
Java_pl_droidsonroids_gif_GifInfoHandle_reset(JNIEnv *__unused  env, jclass  __unused  
class, jlong gifInfo) {  
    GifInfo *info = (GifInfo *) (**intptr_t**) gifInfo;  
    if (info != NULL && reset(info)) {  
        return JNI_TRUE;  
    }  
    return JNI_FALSE;  
}

Our final call chain looks like this:

Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray  
   |_ Java_pl_droidsonroids_gif_GifInfoHandle_reset  
     |_ DDGifSlurp  
       |_ Java_pl_droidsonroids_gif_GifInfoHandle_free

### Testing our assumptions

We can create a test binary that will take a GIF from disk and pass it through our call chain. Notice that we include a _jenv_ header file (sourced from [this](https://blog.quarkslab.com/android-greybox-fuzzing-with-afl-frida-mode.html) Quarkslab post), and we also include the _gif_ header directly from the _android-gif-drawable_ library itself.

Typically, for fuzzing, we would be in one of three scenarios:

*   We are fuzzing pure native library code; we have no dependencies.
*   We have a dependence on the _JNINativeInterface_ (_JNIEnv_), but we can manually create all function arguments we need to call our native code (e.g., _jbyteArray_).
*   We have a dependence on some complex Java object that we can’t create in C. In this case, we must load the APK or a custom-compiled Java class to build our arguments.

In our case, _openByteArray_ has a pretty straightforward prototype, so we are in this second category, where we are able to create the function arguments from C without additional dependencies.

#include <errno.h>  
#include <stdio.h>  
#include <stdlib.h>  
#include <stdint.h>  
#include <stdbool.h>  
#include <string.h>  
#include "../include/jenv.h"  
#include "../android-gif-drawable-1.2.17/android-gif-drawable/src/main/c/gif.h"  
_/* JNI symbols we call directly */  
**extern** jlong Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray(JNIEnv *env, class  
clazz, jbyteArray bytes);  
**extern** **void**  Java_pl_droidsonroids_gif_GifInfoHandle_free(JNIEnv *env, jclass clazz,  
jlong gifInfo);  
**extern** jboolean Java_pl_droidsonroids_gif_GifInfoHandle_reset(JNIEnv *env, class  
clazz, jlong gifInfo);  
**extern** jint JNI_OnLoad(JavaVM *vm, **void** *reserved);  
**static** JavaCTX ctx;  
/**  
 * read_file - read an entire file into a memory buffer  
 * **@path:** path to the input file  
 * **@out_len:** pointer to size_t where the number of bytes read will be stored  
 * Returns a pointer to the data, or NULL on error.  
 * Caller is responsible for freeing the returned buffer.  
 */  
**static** **uint8_t** *read_file(**const** **char** *path, **size_t** *out_len) {  
    FILE *f = fopen(path, "rb");  
    if (!f) return NULL;  
    fseek(f, 0, SEEK_END);  
    **long** sz = ftell(f);  
    rewind(f);  
    if (sz <= 0) { fclose(f); return NULL; }  
    **uint8_t** *buf = malloc((**size_t**)sz);  
    if (!buf) { fclose(f); return NULL; }  
    if (fread(buf, 1, (**size_t**)sz, f) != (**size_t**)sz) {free(buf); fclose(f); return  
NULL; }  
    fclose(f);  
    *out_len = (**size_t**)sz;  
    return buf;  
}  
/**  
 * main - read a GIF file, run DDGifSlurp to trigger CVE-2019-11932, and print results  
 * **@argc:** number of command-line arguments  
 * **@argv:** argument vector, expects GIF file path as argv[1]  
 * Returns exit code, 0 on success, non-zero on error  
 */  
**int** main(**int** argc, **char** *argv**[]**) {  
    if (argc != 2) {  
        fprintf(stderr, "Usage: %s <gif_path>\n", argv[0]);  
        return 1;  
    }  
    **const** **char** *input_path = argv[1];  
    /* 1. Read GIF from disk */  
    **size_t** len = 0;  
    **uint8_t** *data = read_file(input_path, &len);  
    if (!data) {  
        fprintf(stderr, "[-] Failed to read %s\n", input_path);  
        return 1;  
    }  
    /* 2. Initialize Java VM without custom options */  
    if (init_java_env(&ctx, NULL, 0) != 0) {  
        fprintf(stderr, "[-] init_java_env failed\n");  
        free(data);  
        return 1;  
    }  
    /* get JNIEnv */  
    JNIEnv *e = ctx.env;  
    /* 3. Ensure GIF library's JNI_OnLoad runs to set up g_jvm */  
    JNI_OnLoad(ctx.vm, NULL);  
    /* 4. Single open-decode-free cycle */  
    /* Create Java byte[] */  
    jbyteArray arr = (*e)->NewByteArray(e, (jsize)len);  
    if (!arr) {  
        fprintf(stderr, "[-] NewByteArray failed\n");  
        free(data);  
        return 1;  
    }  
    (*e)->SetByteArrayRegion(e, arr, 0, (jsize)len, (**const** jbyte *)data);  
    /* open */  
    jlong gptr = Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray(e, NULL, arr);  
    (*e)->DeleteLocalRef(e, arr);  
    if ((*e)->ExceptionCheck(e) || gptr == 0) {  
        fprintf(stderr, "[-] openByteArray failed\n");  
        (*e)->ExceptionClear(e);  
        free(data);  
        return 1;  
    }  
    /* rewind */  
    Java_pl_droidsonroids_gif_GifInfoHandle_reset(e, NULL, gptr);  
    /* decode (vulnerable) */  
    DDGifSlurp((GifInfo *)(**intptr_t**)gptr, true, false);  
    /* print some info */  
    GifInfo *info = (GifInfo *)(**intptr_t**)gptr;  
    printf("[+] GifInfo at %p: %lu x %lu, %lu frames, loop %lu, error %d\n",  
           (**void***)info,  
           (**unsigned** **long**)info->originalWidth,  
           (**unsigned** **long**)info->originalHeight,  
           (**unsigned** **long**)info->gifFilePtr->ImageCount,  
           (**unsigned** **long**)info->loopCount,  
           (**int**)info->gifFilePtr->Error);  
    /* free */  
    Java_pl_droidsonroids_gif_GifInfoHandle_free(e, NULL, gptr);  
    (*e)->ExceptionClear(e);  
    free(data);  
    return 0;  
}_

The code above will read an image from disk, initialize the Java Virtual Machine (JVM), create a _jbyteArray_ and pass the image through our call chain. At the end, we print some properties from the _GifInfo_ object so we can get some metadata and confirm the code ran to completion without error. Later, we can use this test binary to debug any crashes we may find.

### Building a harness

With the difficult part behind us, we can create a fuzzing harness by wrapping the test code in some _AFL++_ boilerplate. In _main,_ we initialize the Java VM and then create a function which takes a byte array as input. This function, _fuzz_one_input_, will perform all the actions necessary to step through our call chain once with the input provided. We will use Frida to hook this function so AFL can pass inputs to it and collect coverage.

#include <errno.h>  
#include <stdio.h>  
#include <stdint.h>  
#include <jni.h>  
#include "../include/jenv.h"  
#include "../android-gif-drawable-1.2.17/android-gif-drawable/src/main/c/gif.h"  
#define BUFFER_SIZE 65536  
_/* JNI symbols we invoke directly */  
**extern** jlong Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray(JNIEnv *, class,  
jbyteArray);  
**extern** jboolean Java_pl_droidsonroids_gif_GifInfoHandle_reset(JNIEnv *, class,  
jlong);  
**extern** **void** Java_pl_droidsonroids_gif_GifInfoHandle_free(JNIEnv *, jclass, jlong);  
**extern** jint JNI_OnLoad(JavaVM *, **void** *);  
  
**static** JavaCTX ctx;  
  
/*  
 * fuzz_one_input – entry used by Frida-AFL persistent mode.  
 * Creates a GifInfo from the fuzz data, rewinds the stream, runs a full  
 * decode with DDGifSlurp, then frees the structure.  
 */  
__attribute__((visibility("default")))  
**void** fuzz_one_input(**const** **uint8_t** *data, **size_t** len) {  
  JNIEnv *env = ctx.env;  
  if (len < 6) return; /* need at least GIF header */  
  
  /* Create Java byte[] */  
  jbyteArray arr = (*env)->NewByteArray(env, (jsize)len);  
  if (!arr) return;  
  (*env)->SetByteArrayRegion(env, arr, 0, (jsize)len, (**const** jbyte *)data);  
  
  /* GifInfoHandle.openByteArray */  
  jlong gptr = Java_pl_droidsonroids_gif_GifInfoHandle_openByteArray(env, NULL, arr);  
  (*env)->DeleteLocalRef(env, arr);  
  if ((*env)->ExceptionCheck(env) || gptr == 0) {  
    (*env)->ExceptionClear(env);  
    return;  
  }  
  
  /* Rewind so decode starts at offset 0 */  
  Java_pl_droidsonroids_gif_GifInfoHandle_reset(env, NULL, gptr);  
  
  /* Full decode – this is where CVE-2019-11932 triggers */  
  GifInfo *info = (GifInfo *)(**intptr_t**)gptr;  
  DDGifSlurp(info, true, false);  
  
  /* Cleanup */  
  Java_pl_droidsonroids_gif_GifInfoHandle_free(env, NULL, gptr);  
  (*env)->ExceptionClear(env);  
}  
  
/**  
 * main - AFL-Frida fuzzing harness entry point  
 *  
 * Reads up to BUFFER_SIZE bytes from stdin, initializes the Java VM,  
 * invokes fuzz_one_input for persistent-mode decoding, and exits.  
 *  
 * Return: 0 on success (no crash or crash handled by AFL),  
 *         non-zero on initialization or read error.  
 */  
**int** main(**void**) {  
  **uint8_t** buffer[BUFFER_SIZE];  
  **ssize_t** rlen = fread(buffer, 1, sizeof buffer, stdin);  
  if (rlen == -1) return errno;  
  
  /* Start JVM with default options */  
  if (init_java_env(&ctx, NULL, 0) != 0) return 1;  
  
  /* Ensure gif library initialises its global JVM pointer */  
  JNI_OnLoad(ctx.vm, NULL);  
  
  fuzz_one_input(buffer, (**size_t**)rlen);  
  return 0;  
}_

The small Frida script below lets _AFL++_ pass inputs to the harness. It injects a tiny C-hook that copies each AFL test case straight into the function input buffer, tells _AFL++_ exactly where to restart on each iteration, and leverages Frida's instrumentation to collect coverage.

Afl.print(`[*] Starting FRIDA config for PID: ${Process.id}`);  
_// Modules to be instrumented by Frida  
**const** MODULE_WHITELIST = [  
  "fuzz_DDGifSlurp",  
  "libpl_droidsonroids_gif_fixed.so",  
];  
  
// Persistent hook  
**const** hook_module = new CModule(`  
  #include <string.h>  
  #include <gum/gumdefs.h>  
  
  #define BUF_LEN 65536  
  
  void afl_persistent_hook(GumCpuContext *regs, uint8_t *input_buf,  
    uint32_t input_buf_len) {  
  
    uint32_t length = (input_buf_len> BUF_LEN) ? BUF_LEN : input_buf_len;  
    memcpy((void *)regs->x[0], input_buf, length);  
    regs->x[1] = length;  
  }  
  `,  
  {  
    memcpy: Module.getExportByName(null, "memcpy")  
  }  
);  
  
// Persistent loop start address  
**const** pPersistentAddr = DebugSymbol.fromName("fuzz_one_input").address;  
  
// Exclude from instrumentation  
Module.load("libandroid_runtime.so");  
new ModuleMap().values().forEach(m **=>** {  
  if (!MODULE_WHITELIST.includes(m.name)) {  
    Afl.print(`Exclude: ${m.base}-${m.base.add(m.size)} ${m.name}`);  
    Afl.addExcludedRange(m.base, m.size);  
  }  
});  
  
Afl.setEntryPoint(pPersistentAddr);  
Afl.setPersistentHook(hook_module.afl_persistent_hook);  
Afl.setPersistentAddress(pPersistentAddr);  
Afl.setPersistentCount(3000); // Limit how many iterations before reinitializing  
                              // the environment  
Afl.setInMemoryFuzzing();  
Afl.setInstrumentLibraries();  
Afl.done();  
Afl.print("[*] All done!");_

Finally, we can kick off fuzzing on the phone.

panther: # su  
panther: # cd /sys/devices/system/cpu  
panther:/sys/devices/system/cpu # echo performance | tee cpu*/cpufreq/scaling_governor  
performance  
panther:/sys/devices/system/cpu # cd /data/local/tmp/whatsapp  
panther:/data/local/tmp/whatsapp # ./afl-fuzz -O -G 4096 -i in -o out  
./fuzz_DDGifSlurp

I let the fuzzer run for about _7 hours_ before ending the run. We can see from the AFL output below, we executed over _200M_ test cases and recorded _29.1k_ crashes, of which _42_ were saved. AFL applies some heuristics based on signal type, faulting address and edges in the coverage map to determine if a crash is sufficiently interesting to keep. This doesn't mean that each of these crashes is unique.

Crash triage
------------

If we want to triage crashes, we can augment the vulnerable library by adding some additional print statements that will give us more insights into what happens inside the _DDGifSlurp_ _decode_ condition.

if (decode) {  
    _// Print raw values used in calculations  
    printf("[DEBUG] Image.Width=%u, Image.Height=%u, originalWidth=%u,  
originalHeight=%u, currentRasterSize=%u\n",  
           (**unsigned**)gifFilePtr->Image.Width,  
           (**unsigned**)gifFilePtr->Image.Height,  
           (**unsigned**)info->originalWidth,  
           (**unsigned**)info->originalHeight,  
           (**unsigned**)info->rasterSize);  
  
    **int_fast32_t** widthOverflow = gifFilePtr->Image.Width - info->originalWidth;  
    **int_fast32_t** heightOverflow = gifFilePtr->Image.Height - info->originalHeight;  
    **const** **uint_fast32_t** newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;  
  
    // Pretty-print computed overflow and new raster size  
    printf("[DEBUG] widthOverflow=%d, heightOverflow=%d, newRasterSize=%u\n",  
           (**int**)widthOverflow,  
           (**int**)heightOverflow,  
           (**unsigned**)newRasterSize);  
  
    if (newRasterSize> info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {  
        **void** *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize,  
sizeof(GifPixelType));  
        if (tmpRasterBits == NULL) {  
            gifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;  
            break;  
        }  
        info->rasterBits = tmpRasterBits;  
        info->rasterSize = newRasterSize;  
    }  
  
..._

For our convenience, we can also recompile _test_DDGifSlurp_ with _ASan,_ which will give us more verbose information on what went wrong at runtime without necessarily having to dive into LLBD immediately.

➜  cmake \                                                            
    -DANDROID_PLATFORM=31 \  
     -DCMAKE_TOOLCHAIN_FILE=/opt/homebrew/share/android-ndk/build/cmake/android.toolchain.cmake \  
     -DANDROID_ABI=arm64-v8a \  
     -DANDROID_ENABLE_ASAN=ON \  
     -DCMAKE_BUILD_TYPE=Debug \  
     -DCMAKE_C_FLAGS="-g -fsanitize=address -fno-omit-frame-pointer" \  
     -DCMAKE_CXX_FLAGS="-g -fsanitize=address -fno-omit-frame-pointer" \  
     -DCMAKE_SHARED_LINKER_FLAGS="-fsanitize=address" \  
     -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=address" \  
     .  
 ➜  make

There are a few variations of this vulnerability that can be triggered depending on the size and composition of the GIF frames.

In this example, we can see a variation that is almost identical to the one _Awakened_ has in their blog post.

*   _Initial State_: _originalWidth_ has a value of _16697,_ and _originalHeight_ has a value of _65530_.
*   _Frame 0_: _Image.Width_ has a value of _32768,_ which is larger than _originalWidth_. Because of this, we trigger _reallocarray_. However, because _Image.Height_ has a value of _0,_ the final _rasterSize_ becomes _32768*0 = 0_. Due to the internal behavior of _reallocarray,_ we instead _free_ the pointer, leave the dangling reference and _break_.
*   _Frame 1_: _Image.Width_ has a value of _65535_, again larger than _originalWidth_ and _Image.Height_ is again _0,_ resulting in the same behavior, and we free the same pointer again, triggering _ASan_.

Conclusion
----------

Parsers are obviously tricky to get right, and it is easy to make mistakes or have mismatched assumptions about what data the parser will process. This vulnerability was very easy to rediscover using our harness. In fact, the very first crash was reported just a few minutes after the start of the run.

In cases where these types of libraries are included in highly security-critical applications, like messaging apps, they should definitely be subjected to extensive manual and automated testing. If application engineers don't validate library code, it's clear that researchers will (and they may or may not report their findings, no judgments).

### Addendum

This bug was reported and fixed in _2019,_ but I was curious and did some investigation into the issue history of the repository. To my surprise, I found [_an issue_](https://github.com/koral--/android-gif-drawable/issues/343) from _2016_ that was _closed due to inactivity,_ which almost certainly relates to this same vulnerability.

The user reports a crash from _Java_pl_droidsonroids_gif_GifInfoHandle_renderFrame,_ which is the typical way the library uses the vulnerable _DDGifSlurp_ call. In our harness, we do not call this function because:

*   We would have to create a Java _Bitmap_ object, either for each iteration or by reusing a single one with some tricks.
*   For each fuzz iteration, we would need to _lock_ and _unlock_ pixels.

These actions are compute intensive if we perform them thousands of times per second, and we don’t need them to exercise the vulnerable function.

__unused JNIEXPORT jlong JNICALL  
Java_pl_droidsonroids_gif_GifInfoHandle_renderFrame(JNIEnv *env, jclass __unused  
handleClass, jlong gifInfo, jobject jbitmap) {  
    GifInfo *info = (GifInfo *) (**intptr_t**) gifInfo;  
    if (info == NULL)  
        return -1;  
    **long** renderStartTime = getRealTime();  
    **void** *pixels;  
    if (lockPixels(env, jbitmap, info, &pixels) != 0) {  
        return 0;  
    }  
    DDGifSlurp(info, true, false);  
    if (info->currentIndex == 0) {  
        prepareCanvas(pixels, info);  
    }  
    **const** **uint_fast32_t** frameDuration = getBitmap(pixels, info);  
    unlockPixels(env, jbitmap);  
    return calculateInvalidationDelay(info, renderStartTime, frameDuration);  
}

I expect many researchers in the vulnerability research (VR) community are monitoring open and closed GitHub issues from open-source libraries that are loaded by sensitive applications. Given how high-profile WhatsApp is as a target, it’s doubtful that I am the first to look at this specific issue, and others, in the _android-gif-drawable_ library. I would not be surprised at all if this bug was known before 2019.

### References

1. How a double-free bug in WhatsApp turns to RCE - [_here_](https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/)

*   The original blog post by _Awakened_ where they describe the vulnerability and the method for exploitation. The researcher has some other interesting articles on their blog, but strangely, no new entries after the post about the WhatsApp vulnerability. I'm sure one of the research labs acquired an excellent addition to their team!

2. Patched GIF Processing Vuln Still Affects Mobile Apps - [_here_](https://www.trendmicro.com/en_us/research/19/k/patched-gif-processing-vulnerability-cve-2019-11932-still-afflicts-multiple-mobile-apps.html)

*   A really good breakdown by _Trend Micro,_ where they also analyze the impact on other Android applications running out-of-date versions of the library.

3. Android greybox fuzzing with AFL++ Frida mode - [_here_](https://blog.quarkslab.com/android-greybox-fuzzing-with-afl-frida-mode.html)

*   Foundational background on fuzzing JNI functions in various setups: native, weakly linked and strongly linked. Written by Eric Le Guevel [_@quarkslab_](https://x.com/quarkslab).

4. Fuzzing Redux, leveraging AFL++ Frida-Mode on Android native libraries - [_here_](https://knifecoat.com/Posts/Fuzzing+Redux%2C+leveraging+AFL%2B%2B+Frida-Mode+on+Android+native+libraries)

*   This is a post I wrote in 2024, which provides more background on _AFL++ Frida-Mode_ with build information and example usage.

_5. android-gif-drawable_ - [_here_](https://github.com/koral--/android-gif-drawable)

*   The latest vulnerable library version _v1.2.17_ [_here_](https://github.com/koral--/android-gif-drawable/releases/tag/v1.2.17)

Mixture of Experts | 27 June, episode 61

### Decoding AI: Weekly News Roundup

Join our world-class panel of engineers, researchers, product leaders and more as they cut through the AI noise to bring you the latest in AI news and insights.

[Watch the latest podcast episodes](https://www.ibm.com/think/podcasts/mixture-of-experts)