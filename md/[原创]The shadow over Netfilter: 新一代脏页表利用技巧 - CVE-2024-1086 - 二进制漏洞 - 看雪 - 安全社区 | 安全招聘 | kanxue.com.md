> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [bbs.kanxue.com](https://bbs.kanxue.com/thread-287573.htm)

> [原创]The shadow over Netfilter: 新一代脏页表利用技巧 - CVE-2024-1086

CVE-2024-1086
=============

> 依本人之见，这 CVE-2024-1086，乃是潜藏于 Linux 内核深处，那名为 netfilter 的古老机制（?）中，一处令人不安的裂隙。它并非来自外域的邪神，而是源自内部，那本应秩序井然的内存管理，在某些特定、扭曲的条件下，竟会陷入一种可怖的 “用后释放” (Use-After-Free) 状态。  
> 其本质，在于 netfilter 的 nf_tables 组件在处理规则（rules）的垃圾回收和删除时，未能完全斩断其与内存的联系。这就像是，一个本应被彻底遗忘的实体，其幽灵却在内存的深渊中徘徊，等待着被恶意的意志所唤醒。当这幽灵被重新占据，其原有的结构被篡改，便能赋予凡人以僭越神祇的权能——从一个卑微的本地用户，跃升为掌控整个系统的至高存在。这并非寻常的错误，而是一种对底层秩序的亵渎，一种对内存生命周期的扭曲。它揭示了，即使在最坚固的数字堡垒中，亦有其脆弱、可被腐化的角落，足以让混沌的低语  
> 渗透进来，将控制权拱手让与那些窥伺已久的黑暗存在。其影响，正如那无形之触，悄然伸向系统的核心，将权限的锁链一一解开，直至整个世界都暴露在无尽的深渊之前。  
> ------------ Gemini-2.5-flash

该漏洞是一个 netfilter 中处理 HOOK 函数时导致的 Double Free 释放漏洞, 博客涉及了较新 (大概) 的漏洞利用技术 dirty pagetable, 利用 ip 分片机制来无限扩大时间片并且可以控制 skb 释放时间的技巧，以低特权刷新 tlb 等技巧。

环境配置
====

环境以 exp 位于我的 [github 仓库](elink@4a8K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6Y4K9i4c8Z5N6h3u0Q4x3X3g2U0L8$3#2Q4x3V1k6H3k6h3W2%4K9i4c8Z5K9r3q4G2i4K6u0r3d9r3q4U0K9$3g2J5i4K6u0V1g2h3&6A6N6X3g2J5M7$3W2@1P5g2)9J5k6r3!0X3i4K6u0V1M7r3g2A6N6$3W2@1K9r3S2S2L8#2)9J5c8Y4c8J5k6h3g2Q4x3V1k6E0j5i4y4@1k6i4u0Q4x3V1k6W2P5s2m8D9L8$3W2@1i4K6u0r3b7#2k6q4M7#2)9J5c8V1y4h3c8g2)9J5k6o6t1H3x3U0c8Q4x3X3b7I4x3o6R3$3), 包含 rootfs 和 bzImage，一键启动  
linux kernel: linux-6.3.4  
rootfs: busybox  
内核编译配置需要选中以下选项

```
CONFIG_NF_TABLES=y
CONFIG_NF_TABLES_INET=y
CONFIG_USER_NS=y
```

基础知识
====

sk_buff yes!!
=============

本节大部分的知识来源于 [Linux kernel doc](elink@42aK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6V1L8$3y4K6i4K6u0W2K9$3g2J5L8X3g2D9i4K6u0W2L8%4u0Y4i4K6u0r3L8X3g2@1N6$3!0J5K9$3W2F1k6#2)9J5c8Y4y4C8j5Y4g2X3k6W2)9J5k6h3S2@1L8h3H3`.)  
他用来表示一个网络流量包

在内核中的数据结构如下:

```
struct sk_buff {
    ...
    /* These elements must be at the end, see alloc_skb() for details.  */
    sk_buff_data_t      tail;
    sk_buff_data_t      end;
    unsigned char       *head,
                *data;
    unsigned int        truesize;
    refcount_t      users;
    ...
};
```

> [!NOTE]  
> 这个结构体专门用来存放元数据，对于网络包的数据则存放在其他缓冲区当中

```
                                ---------------
                               | sk_buff       |
                                ---------------
   ,---------------------------  + head
  /          ,-----------------  + data
 /          /      ,-----------  + tail
|          |      |            , + end
|          |      |           |
v          v      v           v
 -----------------------------------------------
| headroom | data |  tailroom | skb_shared_info |
 -----------------------------------------------
                               + [page frag]
                               + [page frag]
                               + [page frag]
                               + [page frag]       ---------
                               + frag_list    --> | sk_buff |
                                                   ---------
```

而`sk_buff.head`指向主要的`head buffer`, 而这个 head buffer 分为两个部分

*   data bufer: 包含头部，有时候包含一些载荷, 这一部分由常见的 helper 程序使用，例如`skb_put(), skb_pull()`
*   shared info: 只读数据的一些数组指针  
    sk_buff 在发送流量包的时候分配，并且可以自定义大小，但有一定范围，且本问涉及到的 order-4 也在范围内。

Netfilter: iptables 的后继者
------------------------

Netfilter 是一种 linux 内核网络过滤器  
Netfilter 包含几种 table(`struct xt_table`), 每个 table 用来存储不同的配置信息  
每个 table 有多个 chain(`struct xt_table_info`), chain 表示对报文的拦截点，就比如一个网络层 ipv4 报文传过来，他会对每个拦截点进行检测，也就是每条 chain  
而每个 chain 则包含一些 rule(`struct ipt_entry`), 一条 rule 则包含一个或多各正则匹配规则 (match), 和一个执行动作  
其拥有以下几种功能 (table):

1.  filter 表: 过滤报文: 包含 3 个 chain:INPUT/OUTPUT/FORWARD
2.  mangle 表: 修改报文， 包含 5 个 chain
3.  connection track: 会话的连接跟踪, 包含 2 个 chain,OUTPUT/PREROUTING
4.  NAT: 包含三个 chain, PREROUTING/OUPUT/POSTROUTIN

相关结构体
-----

```
/* Furniture shopping... */
struct xt_table {
    struct list_head list;
 
    /* What hooks you will enter on */
    unsigned int valid_hooks;
 
    /* Man behind the curtain... */
    struct xt_table_info __rcu *private; //用来存放指向`xt_table_info`的指针
 
    /* Set this to THIS_MODULE if you are a module, otherwise NULL */
    struct module *me;
 
    u_int8_t af;        /* address/protocol family */
    int priority;       /* hook order */
 
    /* called when table is needed in the given netns */
    int (*table_init)(struct net *net);
 
    /* A unique name... */
    const char name[XT_TABLE_MAXNAMELEN];
};
```

这个结构体就是上述的表 table, 存在一个 private 字段，类型为`struct xt_table_info`且添加了`__rcu`的标识, 这个标识表示在读取的时候不用加锁，  
但在写的时候更新数据

```
/* The table itself */
struct xt_table_info {
    /* Size per table */
    unsigned int size;
    /* Number of entries: FIXME. --RR */
    unsigned int number;
    /* Initial number of entries. Needed for module usage count */
    unsigned int initial_entries;
 
    /* Entry points and underflows */
    unsigned int hook_entry[NF_INET_NUMHOOKS];          //存放每个chains的偏移
    unsigned int underflow[NF_INET_NUMHOOKS];           //存放每个chains中default rule的偏移
 
    /*
     * Number of user chains. Since tables cannot have loops, at most
     * @stacksize jumps (number of user chains) can possibly be made.
     */
    unsigned int stacksize;
    void ***jumpstack;
 
    unsigned char entries[] __aligned(8);
};
```

这里的`entries`的每个字段则存放了每个 cpu 所对应的专属 buf, 如下

```
┌──────────────┬───────────────────┬─────────┐
│void  entries0│                   │CPU0 bufs│
├──────────────┼─────────┐         │         │
│void  entries1│         └─────────┴─────────┘
├──────────────┤
│void  entries2│
└──────────────┘
```

而每个`CPU bufs`里面包含的内容则是一个个`chains`数组

```
┌───────────┬──────────────┬───────────┐
│ chains0   │   chains1    │   chains2 │
└───────────┴──────────────┴───────────┘
```

然后每个 chains 里面则包含了一条条 rules

```
┌──────┬───────┬──────┐
│rule0 │ rule1 │ rule2│
└──────┴───────┴──────┘
```

那么由于每个 chains 里面的 rule 条数都可能不同，所以需要还存在一定的偏移字段  
所以`struct xt_table_info.hook_entry[]`里面就存的是在`cpu bufs`里面每个 chains 的起始偏移  
这样就可以精准定位到每个 chains 下的 rule  
然后由于这里还存在一个默认规则字段, 所以在对应的`struct xt_table.underflow[]`则存放的是每个 chains 的默认 rule 的相对偏移

然后每条 rule 是使用`sturct ipt_entry`来表示

```
struct ipt_entry {
    struct ipt_ip ip;
 
    /* Mark with fields that we care about. */
    unsigned int nfcache;
 
    /* Size of ipt_entry + matches */
    __u16 target_offset;
    /* Size of ipt_entry + matches + target */
    __u16 next_offset;
 
    /* Back pointer */
    unsigned int comefrom;
 
    /* Packet and byte counters. */
    struct xt_counters counters;
 
    /* The matches (if any), then the target. */
    unsigned char elems[0];
};
```

而每一条 rule 包含多个匹配规则`struct xt_entry_match`和一个执行动作`struct xt_entry_target`

```
struct xt_entry_match {
    union {
        struct {
            __u16 match_size;
 
            /* Used by userspace */
            char name[XT_EXTENSION_MAXNAMELEN];
            __u8 revision;
        } user;
        struct {
            __u16 match_size;
 
            /* Used inside the kernel */
            struct xt_match *match;
        } kernel;
 
        /* Total length */
        __u16 match_size;
    } u;
 
    unsigned char data[0];
};
 
struct xt_entry_target {
    union {
        struct {
            __u16 target_size;
 
            /* Used by userspace */
            char name[XT_EXTENSION_MAXNAMELEN];
            __u8 revision;
        } user;
        struct {
            __u16 target_size;
 
            /* Used inside the kernel */
            struct xt_target *target;
        } kernel;
 
        /* Total length */
        __u16 target_size;
    } u;
 
    unsigned char data[0];static struct sk_buff *ip_rcv_core(struct sk_buff *skb, struct net *net)
{
};
```

通信机制
----

netfilter 通过`setsockopt, getsockopt`来进行用户 - 内核的交互,  
在此基础上`nftables`实现了自己的一个框架，允许不同的防火墙来实现自己和用户空间的通信函数  
这里主要涉及了`nf_register_sockopt()`函数将`nf_sockopt_ops`结构体实例注册到`netfilter`管理的全局链表当中  
注册完毕就可以调用`nf_sockopt_find()`来查找对应的`nf_sockopt_ops`

使用
--

用来表示数据包的处理指令

```
/* Responses from hook functions. */
#define NF_DROP 0
#define NF_ACCEPT 1
#define NF_STOLEN 2
#define NF_QUEUE 3
#define NF_REPEAT 4
#define NF_STOP 5   /* Deprecated, for userspace nf_queue compatibility. */
```

下面的则是 netfilter 的 hook 时机

```
enum nf_inet_hooks {
    NF_INET_PRE_ROUTING,
    NF_INET_LOCAL_IN,
    NF_INET_FORWARD,
    NF_INET_LOCAL_OUT,
    NF_INET_POST_ROUTING,
    NF_INET_NUMHOOKS,
    NF_INET_INGRESS = NF_INET_NUMHOOKS,
};
enum nf_dev_hooks {
    NF_NETDEV_INGRESS,
    NF_NETDEV_EGRESS,
    NF_NETDEV_NUMHOOKS
};
```

*   `NF_INET_PRE_ROUTING`: 路由前，数据包刚被网卡驱动接受，进入 IP 层
*   `NF_INET_LOCAL_IN`: 本地进入
*   `NF_INET_FORWARD`: 转发，发现数据包的目标不是本机，则需要转发到另一个网络，转发前将会触发钩子
*   `NF_INET_LOCAL_OUT`: 本地出，本机应用程序生成了数据包，想要发送出去的时候被触发
*   `NF_INET_POST_ROUTING`: 路由后, 数据包离开系统的最后一个钩子点，在经过`LOCAL_OUT`还是`FORWARD`之后，交给网卡驱动之前
*   `NF_INET_NUMHOOKS`: 记录 hook 数量

> [!NOTE]  
> 在调试时，开启 netfilter 的情况下，向自身主机发送 ip 头`dst_addr=255.255.255.255, src_addr=1.1.1.1`,  
> socket 系统调用中`sock_addr=127.0.0.2`的环回地址的情况下，经过的 HOOK 点顺序是`NF_INET_LOCAL_OUT, NF_INET_POST_ROUTING, NF_INET_PRE_ROUTING`, 这里在后面的 ip 发包在调试过程中会有更详细的讲解

libnftnl & libmnl
-----------------

这两个库实际上是方便用户来编写 netfilter 的 rules, 还有通过 netlink 来访问内核提供的 NFTABLES 板块，可以直接从[官网](elink@fcbK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6%4N6%4N6Q4x3X3g2F1k6i4c8X3K9h3I4@1k6i4u0Q4x3X3g2G2M7X3N6Q4x3V1k6H3M7X3!0B7k6h3y4@1M7#2)9J5c8X3I4A6j5X3&6W2N6r3k6A6L8s2c8W2M7W2)9#2k6Y4q4#2k6i4g2W2i4K6u0r3)获取源码然后自己编译

IP 发送网络包
--------

构造 IP 包发送，需要用到两种系统调用, 分别是`socket, sendto`  
socket 系统调用用来构建套接字 socket, 套接字用来收发数据，并且与内核 sock 进行关联  
sendto 则利用 socket 传回的 fd 来发送信息

```
...
    sendto_ipv4_ip_sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
...
```

这里的`SOCK_RAW`表示我们自己构造 IP 头部

用户使用`sendto`向指定地址发送消息的时候，会首先调用内核系统调用`__x64_sys_sendto`  
在本次漏洞利用中我们是构造了`RAW_INET`包, 该 flag 表示我们是想要由自身来提供头部信息  
这里大致介绍一下在`sendto`系统调用的流程中，执行流在内核中的旅行路线, 这里将主要聚焦于 netfilter hook 点

1.  首先调用`__sys_sendto -> sock_sendmsg -> sock_sendmsg_nosec -> inet_sendmsg`
2.  `inet_sendmsg`根据 socket 来执行间接调用函数，这里经过调试发现是`raw_sendmsg()`(这里 ops 的初始化是在 socket 的创建过程中，其中依然涉及大量间接调用的赋值)
3.  `raw_sendmsg()`是发送网络数据包的核心代码，这里调用`raw_sendhd_rinc()`, 该函数在最后涉及到`NF_INET_LOACL_OUT`，这是这个流程遇到的第一个 hook 点

```
static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
    struct inet_sock *inet = inet_sk(sk);
    struct net *net = sock_net(sk);
    struct ipcm_cookie ipc;
...
    if (hdrincl)
        err = raw_send_hdrinc(sk, &fl4, msg, len,
                      &rt, msg->msg_flags, &ipc.sockc);
...
}
static int raw_send_hdrinc(struct sock *sk, struct flowi4 *fl4,
               struct msghdr *msg, size_t length,
               struct rtable **rtp, unsigned int flags,
               const struct sockcm_cookie *sockc)
{
...
    err = NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
              net, sk, skb, NULL, rt->dst.dev,
              dst_output);
...
}
```

1.  在上面遇到的第一个 hook 点中, 传递参数定义了回调函数`dst_output()`, 而`dst_output()->ip_output()`
2.  `ip_output()`函数主体最后会调用`NF_INET_POST_ROUTING`, 之后是调用回调函数`ip_finish_output()`来清除 skb

```
int ip_output(struct net *net, struct sock *sk, struct sk_buff *skb)
{
    struct net_device *dev = skb_dst(skb)->dev, *indev = skb->dev;
 
    IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb->len);
 
    skb->dev = dev;
    skb->protocol = htons(ETH_P_IP);
 
    return NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,
                net, sk, skb, indev, dev,
                ip_finish_output,
                !(IPCB(skb)->flags & IPSKB_REROUTED));
}
EXPORT_SYMBOL(ip_output);
```

1.  此时如果你发送的目的地址环回地址，则会触发软中断，软中断调用`__netif_receive_skb_one_core`来触发，经过一系列调用链条最终调用`ip_rcv()`
2.  `ip_rcv()`首先调用`ip_rcv_core()`处理接收到的 skb, 然后触发`NF_INET_PRE_ROUTING`hook, 在一些相应的 hook 函数完毕后调用回调函数`ip_rcv_finish()`

```
/*
 * IP receive entry point
 */
int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
       struct net_device *orig_dev)
{
    struct net *net = dev_net(dev);
 
    skb = ip_rcv_core(skb, net);
    if (skb == NULL)
        return NET_RX_DROP;
 
    return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
               net, NULL, skb, dev, NULL,
               ip_rcv_finish);
}
```

1.  `ip_rcv_finish()`调用函数`ip_rcv_finish_core()`函数，主要判断目的地址的规范性一类然后来判断是否需要丢弃
2.  如果不需要丢弃，则调用`dst_input()`
3.  `dst_input()`会通过间接调用到`ip_local_deliver()`, 其首先判断该 ip 包是否是分片包，如果是则调用`ip_defrag()`, 否则触发钩子`NF_INET_LOCAL_IN`

```
/*
 *  Deliver IP Packets to the higher protocol layers.
 */
int ip_local_deliver(struct sk_buff *skb)
{
    /*
     *  Reassemble IP fragments.
     */
    struct net *net = dev_net(skb->dev);
 
    if (ip_is_fragment(ip_hdr(skb))) {
        if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))
            return 0;
    }
 
    return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,
               net, NULL, skb, skb->dev, NULL,
               ip_local_deliver_finish);
}
EXPORT_SYMBOL(ip_local_deliver);
```

1.  `ip_defrag()`该函数用来处理分片包, 该函数会调用`ip_find()`来查找是否已经有同一个 IP 包的分片组成的队列，如果有则返回队列，否则创建新的队列
2.  `ip_defrag()`继续调用`ip_frag_queue()`来真正处理该分片的信息
3.  `ip_frag_queue()`来查看该 ip 头部的字段长度是否安全，如果出现错误则会直接丢弃该 skb 并且释放整个队列
4.  `ip_frag_queue()`会检查几个条件来判断是否 ip 包是否全部分片均到达，如果到达则调用`ip_frag_reasm()`来重组新的 skb, 然后将 skb 重新注入到网络协议栈的接收路径
5.  之后通过返回 0，返回到`ip_local_deliver()`然后触发钩子`NF_INET_LOCAL_IN`, 之后继续调用回调函数

所以，如果我们发送一个数据包分片的时候，经过的 netfilter hook 点顺序可能是  
`NF_INET_LOCAL_OUT -> NF_INET_POST_ROUTING -> NF_INET_PRE_ROUTING -> NF_INET_LOCAL_IN`

漏洞原因
====

漏洞出自于`nf_hook_slow()`

```
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
         const struct nf_hook_entries *e, unsigned int s)
{
    unsigned int verdict;
    int ret;
 
    for (; s < e->num_hook_entries; s++) {
        verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
        switch (verdict & NF_VERDICT_MASK) {
        case NF_ACCEPT:
            break;
        case NF_DROP:
            kfree_skb_reason(skb,
                     SKB_DROP_REASON_NETFILTER_DROP);
            ret = NF_DROP_GETERR(verdict);
            if (ret == 0)
                ret = -EPERM;
            return ret;
        case NF_QUEUE:
            ret = nf_queue(skb, state, s, verdict);
            if (ret == 1)
                continue;
            return ret;
        default:
            /* Implicit handling for NF_STOLEN, as well as any other
             * non conventional verdicts.
             */ return 0;
        }
    }
 
    return 1;
}
EXPORT_SYMBOL(nf_hook_slow);
```

在 switch case 语句中`NF_DROP`的选项, 这是由于当用户所设计的 netfilter hook 函数最后返回`NF_DROP`时即将执行的程序流程

这里的流程将会首先释放这个 skb，但是这里程序再次判断了`NF_DROP_GETERR`来获取返回参数，  
这就给了用户一定的操作空间，如果可以通过这个函数将 ret 修改为 NF_ACCEPT, 也就是 1,  
那么当这个函数返回后将回到下面的`nf_hook()`函数

`nf_hook()`函数返回 1 则会导致调用后续的`okfn()`, 这里使用`ip_forward()`进行举例  
该函数将在最后调用`NF_HOOK()`函数

```
...
    return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,
               net, NULL, skb, skb->dev, rt->dst.dev,
               ip_forward_finish);
...
```

而`NF_HOOK()`函数将会根据`nf_hook()`函数的返回值来决定是否调用`okfn`参数指针所指向的地址  
返回值为 1 则说明 hook 函数处理的返回值为`NF_ACCEPT`

```
static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
    struct net_device *in, struct net_device *out,
    int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
    int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
    if (ret == 1)
        ret = okfn(net, sk, skb);
    return ret;
}
```

那么就能在之后对 skb 进行二次释放, 因此导致了 double free

触发方式
====

知道了漏洞出处，接下来的步骤便是尝试触发，在`nf_hook_slow()`函数当中

```
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
         const struct nf_hook_entries *e, unsigned int s)
{
    ...
    for (; s < e->num_hook_entries; s++) {
        verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
        switch (verdict & NF_VERDICT_MASK) {
        case NF_ACCEPT:
            break;
        case NF_DROP:
            kfree_skb_reason(skb,
                     SKB_DROP_REASON_NETFILTER_DROP);
            ret = NF_DROP_GETERR(verdict);
    ...
```

这里的 for 循环是调用当前 hook 点里面所有的 hook, 并且返回值是可以由用户构造的  
所以为了满足我们的目的，需要 verdict 满足:

```
static inline int NF_DROP_GETERR(int verdict)
{
    return -(verdict >> NF_VERDICT_QBITS);
}
 
#define NF_DROP 0                 
#define NF_ACCEPT 1
#define NF_VERDICT_MASK 0x000000ff
#define NF_VERDICT_QBITS 16
```

```
1. verdict & NF_VERDICT_MASK == NF_DROP;
2. NF_DROP_GETERR(verdict) == NF_ACCEPT;
```

因此计算得出可以构造`verdict = 0xffff0000`即可满足这样一个条件, 而构造 verdict 我们可以通过向内核传递在用户态构造的 netfilter tables-chains-rules 来达成，这一过程可以通过 netlink 来完成传递。

相关技巧
====

Page Double Free
----------------

从`__free_pages()`函数可以看出

```
void __free_pages(struct page *page, unsigned int order)
{
    /* get PageHead before we drop reference */
    int head = PageHead(page);
 
    if (put_page_testzero(page))
        free_the_page(page, order);
    else if (!head)
        while (order-- > 0)
            free_the_page(page + (1 << order), order);
}
EXPORT_SYMBOL(__free_pages);
```

当使用`put_page_testzero()`发现页面的引用计数为 1, 则将释放他  
而如果此时我们不做任何事直接将他应用在 double free 上，则`put_page_testzero()`将会发现`page.refcount == 0`从而报错

```
static inline int put_page_testzero(struct page *page)
{
    VM_BUG_ON_PAGE(page_ref_count(page) == 0, page);
    return page_ref_dec_and_test(page);
}
```

因此可以在 double free 中途插入重分配，使得 refcount++, 这样就可以绕过这部分检查  
作者的例子如下:

```
static void kref_juggling(void)
{
    struct page *skb1, *pmd, *pud;
 
    skb1 = alloc_page(GFP_KERNEL);  // refcount 0 -> 1
    __free_page(skb1);  // refcount 1 -> 0
    pmd = alloc_page(GFP_KERNEL);  // refcount 0 -> 1
    __free_page(skb1);  // refcount 1 -> 0
    pud = alloc_page(GFP_KERNEL);  // refcount 0 -> 1
 
    pr_err("[*] skb1: %px (phys: %016llx), pmd: %px (phys: %016llx), pud: %px (phys: %016llx)\n", skb1, page_to_phys(skb1), pmd, page_to_phys(pmd), pud, page_to_phys(pud));
}
```

Order 4 -> Order 0
------------------

在`__do_kmalloc_node()`函数当中，

```
#define KMALLOC_MAX_CACHE_SIZE  (1UL << KMALLOC_SHIFT_HIGH)
#define KMALLOC_SHIFT_HIGH  (PAGE_SHIFT + 1)
#define PAGE_SHIFT      12
 
static __always_inline
void *__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)
{
    ...
    if (unlikely(size > KMALLOC_MAX_CACHE_SIZE)) {
        ret = __kmalloc_large_node(size, flags, node);
        ...
    ret = __kmem_cache_alloc_node(s, flags, node, size, caller);
    ...
}
```

在使用`kmalloc`分配内存堆块的过程中，  
如果分配 size 大小大于`KMALLOC_MAX_CACHE_SIZE`  
那么将会使用`alloc_page()`直接从伙伴系统申请页面，kfree 也是同理

```
void kfree(const void *object)
{
    struct folio *folio;
    struct slab *slab;
    struct kmem_cache *s;
 
    trace_kfree(_RET_IP_, object);
 
    if (unlikely(ZERO_OR_NULL_PTR(object)))
        return;
 
    folio = virt_to_folio(object);
    if (unlikely(!folio_test_slab(folio))) {
        free_large_kmalloc(folio, (void *)object);
        return;
    }
 
    slab = folio_slab(folio);
    s = slab->slab_cache;
    __kmem_cache_free(s, (void *)object, _RET_IP_);
}
EXPORT_SYMBOL(kfree);
```

但某些对象即使小于`KMALLOC_MAX_CACHE_SIZE`, 同样会由于开发人员减少开销的操作来直接使用`alloc_page()`, 例如 PTE page  
除此之外，当对象使用`alloc_pages()`分配或者释放的时候，如果大小小于`order 3`, 则会从 PCP list(以前也被叫做冷热页，这里主要是为了防止多次访问全局的 buddysystem 的时候造成的阻塞，因此每个 CPU 拥有自己的 free page 列表) 里面进行分配或者释放，也就是说当内核申请页表空间的时候首先将会使用`alloc_pages()`在当前 CPU 的 pcp list 里面分配页面

```
alloc_pages                                                 alloc_pages_node                     
    │                                                               │                            
    ▼                                                               ▼                            
alloc_pages_node ──────────►__alloc_pages_node            __alloc_pages_node                     
                                   │                                │                            
                                   ▼                                │                            
                            __alloc_pages ◄─────────────────────────┘                            
                                   │                                                             
            ┌──────────────────────┴─────────┬───────────────────────────────────┐               
            ▼                                ▼                                   ▼               
   prepare_alloc_pages             get_page_from_freelist                 alloc_pages_slowpath     
   get zonelist info                  alloc new pages                        reclaim pages
                                              │                               alloc new pages
                                              ▼                                                  
                                            rmqueue                                              
                                              │                                                  
                                ┌─────────────┴──────────────┐                                   
                                │                            │                                   
                                ▼                            ▼                                   
                        rmqueue_pcplist             rmqueue_buddysystem                          
                       order < 3 allocation         allocate from buddysystem        
                                │
                          ┌─────┴──────────────────┐
                      empty(pcp list)        not empty
                          ▼                        ▼
                      rmqueu_bulk             return pcp_list chunk
                 reload pcp from buddysystem
```

详细的内存管理可以查看[内存管理浅析](elink@cc7K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6Y4K9i4c8Z5N6h3u0Q4x3X3g2U0L8$3#2Q4x3V1k6H3k6h3W2%4K9i4c8Z5K9r3q4G2i4K6u0r3d9r3q4U0K9$3g2J5i4K6u0V1g2h3&6A6N6X3g2J5M7$3W2@1P5g2)9J5k6r3!0X3i4K6u0V1M7r3g2A6N6$3W2@1K9r3S2S2L8#2)9J5c8X3u0D9L8$3u0Q4x3V1k6E0j5i4y4@1k6i4u0Q4x3V1k6K6P5i4y4@1k6h3#2Q4x3V1k6E0k6h3#2G2M7Y4W2Q4y4h3k6E0j5h3&6S2k6$3g2E0k6h3&6@1i4K6u0W2L8h3b7`.)  
目前目标:

1.  分配指定大小 skb,
2.  准备双重释放该 skb，
3.  第一次释放 skb, 延迟第二次释放 skb
4.  分配页表, 占领该 skb
5.  第二次释放 skb, 此时页表也被释放
6.  重新申请该页

目前可以获取的情报:

1.  分配的 skb 能够被页表所占领
2.  页表由`alloc_pages()`分配，从 pcp list 得到
3.  skb 如果小于 8K, 则将从 slab allocator 分配
4.  skb 如果大于 8K 且小于 8x4K, 则从 page allocator 分配或者释放，但是是从 pcp list 进行分配
5.  如果 skb 大于 8x4k, 同样从 page allocator 分配, 直接从 buddysystem 获取
6.  如果 skb 采用 3 分配和释放，则 skb 释放后只会回到 slab 当中，无法造成 skb 和 PTE page 占用同一页
7.  如果 skb 采用 4 分配和释放，则 skb 虽然是从 pcp list, 但是 pcp list 里面也有 order 差异，也无法造成共同占用
8.  skb 采用 5, 则 skb 将会释放回 buddysystem 当中，此时有可能造成共同占用，当 pcp list 没有符合的页面就将从 buddysystem 获取

综上，skb 将会以 order-4(16x4KB) 的形态出击

而为了造成 pcp list 没有符合的页面，需要首先耗尽其中所有的页  
内核函数`rmqueue_bulk()`由`__rmqueue_pcplist()`分配，当 pcplist 为空的时候，就将使用该函数来填充`rmqueue_bulk`,  
该函数将从 buddysystem 获取页面来填充 pcplist

因此这里可以堆喷`PTE page`来消耗该 pcplist

IP fragment trick
-----------------

![](https://bbs.kanxue.com/upload/attach/202507/955986_Q8W9Z8SPHKW4Q3A.png)  
使用了 IP 包分片的技巧来巧妙的进行延迟的 double free  
IP 分片这一块是 408 网络的重点部分:), 如果记得不太详细可以直接查看该[博客](elink@649K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3j5h3y4C8k6i4c8H3N6i4y4Z5k6i4u0K6i4K6u0W2L8X3g2@1i4K6u0r3j5X3I4G2k6#2)9J5c8X3W2H3i4K6u0V1k6Y4u0S2k6$3#2W2L8Y4c8S2N6r3W2G2L8W2)9J5k6r3W2F1i4K6u0V1k6r3g2@1j5h3W2D9i4K6u0r3)  
在上面基础知识我们知道如果传递 IP 分片到目标机器，首先并不会直接送入上层进行分析，而是在内核维持一个 skb 队列，  
等待队列满了之后再递交上层处理

我们知道在上面的漏洞点中，我们可以在处理 netfilter hook 函数的时候将某个 skb 进行一次释放，而释放过后依旧会走完全程，  
在通过漏洞释放完 skb 之后，`skb->len`字段将会被随机数覆盖，这是内核的保护机制, 此时二次释放该 skb 可能会导致内核 panic  
因此何时触发二次释放就十分重要，  
这里存在两个技巧：

1.  分片包在内核维持的队列有时间限制，一旦超过了这个时间限制，则该队列的 skb 包则会全部释放，  
    这个时间限制由内核的 sysfs 文件系统掌控, 位于`/proc/sys/net/ipv4/ipfrag_time`, 而设置他并不需要 root 权限，  
    因此我们如果将该值调大，那完全可以创建一个无限大的窗口供我们使用
2.  仔细阅读`ip_frag_queue`的代码，当他检查该分片头部的时候如果`offset==len`, 那么将会判断是错误包，直接释放该 skb 队列, 并且不会检测之前放入 queue 的头部是否正确

整合该两点，我们就可以通过构造 IP 头，在任意我们想要的时机对一个 skb 进行 double free

```
        set ipfrag_time=9999   │
                  │            │
                  │            │
                  │            │
                  ▼            │
       sendto ip fragment skb1 │
                  │            │ ─┐
freed by exploit  ▼            │  │
                  │            ▼  │
         waiting in queue      │  │ i can do everthing i want
                  │            │  ▼
                  │            │  │
                  ▼            │  │
                  │            │ ─┘
                  │            │     sendto ip fragment skb2
                  └──────────┬─┴───── but offset == len
                             │
                             ▼
                  free skb1 skb2 in current cpu
              (double free)
```

堆喷 PTE
------

需要堆喷 PTE, 在 dirtypagetable 里面就已经讲解到, 可以通过用户使用 mmap 来分配页表,  
但是 mmap 的时候并不是分配页表的时候，他会首先在内核 task_struct 中建立 VMA, 当用户访问 VMA 区域内的地址的时候才会出发 page fault,  
然后造成页表分配

但是如果选择的映射区域不准确，则可能会造成一系列分配例如 PUD,PMD 的额外分配, 这样在我们堆喷的过程中就可能造成噪音从而导致利用失败

那么我们就可以选择舍弃一部分 PTE, 那就是首先通过分配某个 PTE 的第一个 page 来提前将 PMD 和 PUD 分配完毕, 例子如下

```
                     PUD              PMD             PTE           page
             ┌────►┌────────┐  ┌──►┌─────────┐ ┌──►┌─────────┐   ┌─────────┐
   PGD       │     │        ├──┘   │         ├─┘   │         ├──►│ aaaaaaa │
┌───────┐    │     ├────────┤      ├─────────┤     ├─────────┤   │         │
│       ├────┘     │        │      │         │     │         │   │         │
├───────┤          │        │      │         │     │         │   │         │
│       │          │        │      │         │     │         │   │         │
│       │          └────────┘      └─────────┘     └─────────┘   └─────────┘
└───────┘
```

对于提前的 VMA 写入就将导致 PUD 和 PMD 的分配，接下来当继续访问在 PUD/PMD 可表示的虚拟地址范围内的地址就可以保证稳定分配 PTE

Dirty pageDirectory
-------------------

作者由 dirtypagetable 启发而来, 简单介绍一下 dirty pagetable 的原理在于:

> [!NOTE]  
> 当存在 UAF 的时候, 将漏洞堆块和 PTE 页表分配到一起，然后就可以通过操作漏洞堆块来影响 PTE 页表，从而导致任意物理地址写  
> 但是这个步骤需要漏洞堆块稳定能操作，比如说是稳定写入字节

```
   step1 ────free the obj─► step2 ──mmap──────► step3
┌───────────┐        ┌─────────────┐     ┌───────────┐
│vuln object│        │             │     │   PTE     │
└───────────┘        └─────────────┘     └───────────┘
                                               ▲
                                               │
                                ACCESS PTE BY VULN OBJECT
```

但可惜的是有时候无法获取一个稳定的漏洞利用模块，比如这次漏洞的 skb，因此作者仅仅使用一次漏洞触发，  
之后的操作完全是对于用户虚拟地址的访问来达成任意物理地址读写  
实际操作起来的原理十分的简单，仅仅是使 PMD 和 PTE 均分配到同一个物理页面，这样做导致的后果就是:

> [!IMPORTANT]  
> 原来 PTE 访问的 page 页面会变成 PMD 访问到的 PTE 页面，所以如果能够在原来 PTE 访问的 page 页面伪造合适的页表项, 则就可以通过 PMD 来执行任意物理地址读写操作

```
      ┌───► PUD0 ────► PMD0 ───────► PTE0 ──────►  page0 ───► ???
      │                               │             │          │
      │                               │             │          │
      │                               │             │          │
PGD ──┤                  ┌─same phys──┘ ┌─same phys─┘     ┌─?──┘
      │                  │              │                 │
      │                  │              │                 │
      └───► PUD1 ────► PMD1(PTE0)───► PTE1(page0) ───► page1(???)
```

TLB 刷新
------

[TLB](elink@eefK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6W2L8W2)9J5k6i4N6A6K9$3W2H3k6h3c8A6j5g2)9J5k6h3!0J5k6#2)9J5c8Y4N6A6K9$3W2Q4x3V1k6f1M7X3q4F1M7$3I4S2N6r3W2G2L8W2)9#2k6X3I4G2L8$3E0S2M7$3W2V1k6g2)9#2k6X3u0#2k6X3k6W2M7R3`.`.) 用来缓存虚拟地址到物理地址的映射，从而可以使得加快页表访存,  
所以在 dirty pagedirectory 的工作下我们需要清空 TLB 来保证该技术的稳定性, 而这一步骤也可以被称为刷新 TLB

这里该作者提出的刷新方法是在堆喷 PMD 和 PTE 的时候，可以将他们标记为共享页面，然后通过创建子进程，然后该子进程调用`munmap()`刷新内存 TLB, 从而导致父进程的 TLB 也会进行刷新，该操作在需要我们不断修改页表的环境下是极其重要的  
最后让子进程进入睡眠

漏洞利用流程
======

接下来讲解具体流程:

1.  创建用户和网络命名空间，在其中可以让我们执行特权操作
2.  做环境准备，例如绑定 cpu 核等
3.  启动环回网卡, 然后禁用 rpf(反向路径转发), 因为后续需要使用特制 ip 头
4.  构造 netfilter hook, 这里 hook 点为`NF_INET_PRE_ROUTING`, 具体原因可以参考基础知识环节
5.  预分配 PUD，PMD,PTE，socket 等结构体，来减少后续漏洞利用噪音的产生，这里虚拟地址的计算通过几个巧妙的宏来实现

```
#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define INDEX_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
    ((void*)(_pgd_index_to_virt((size_t)(pud_index)) + _pud_index_to_virt((size_t)(pmd_index)) + \
    _pmd_index_to_virt((size_t)(pte_index)) + _pte_index_to_virt((size_t)(page_index)) + (size_t)(byte_index)))
...
 
    void *addr = mmap((void *)INDEX_TO_VIRT(1, 0, 0, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (addr == MAP_FAILED) {
          perror("mmap failed"); // perror 会打印出具体的错误原因
          exit(EXIT_FAILURE);
    }
    // page fault: allocate PUD PMD PTE page
    *(size_t *)INDEX_TO_VIRT(1, 0, 0, 0, 0) = (size_t)0xDEADBEEF;
 
    // pre allocation: only create the vma (mostly PTE page, and some PMD page)
    for(size_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT; i++){
        void *retv = mmap((void *)INDEX_TO_VIRT(2, 0, i, 0, 0), 0x2000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        if (addr == MAP_FAILED) {
            perror("mmap failed"); // perror 会打印出具体的错误原因
            exit(EXIT_FAILURE);
        }
    }
     
    // occur page fault
    for(size_t i = 0; i < CONFIG_PTE_SPRAY_AMOUNT/CONFIG_PAGE_ENTRY_NUM; i++){
        *(char *)INDEX_TO_VIRT(2, i, 0, 0, 0) = '0x41';
    }
```

1.  分配大量 udp skb, 仅仅用来放在 double free 之间来防止错误
2.  分配 skb1, 该 skb1 出发 netfilter hook 漏洞, 进行释放, 由于是分配 0x8000, 所以从 order-4 的 buddysystem 分配和释放，但是此时还在分片队列里面
3.  释放大量 udp skb
4.  此时分配大量 PTE 页，此时从 order-0 分配，首先耗尽 pcp-list, 然后 pcp-list 补充页面则从 buddysystem, 只需要数量足够大，就会导致分配到的 PTE 页面的堆块和 skb 数据块重叠
5.  发送损坏的 skb2, 触发 skb queue 释放，从而导致刚刚分配到的 PTE 页面释放
6.  此时分配 pmd 页面, 这里大家可能会担心，一个 order-4 的页面的释放到 buddy system, 为什么一个 order-0 的 getpages 请求能获取到, 这是因为实际上此时被 double free 释放的 PTE 所在的 page 已经被修改为 order0 了, 而在释放 skb 的时候并不会检查该 page 的字段，按照常规的`kfree->free_large_kmalloc`之时检测到的只会是 order-0 页面的 freepage，该 pmd 页面将会和刚刚的 pte 页面共享同一个物理页
7.  在物理地址中同样可能存在 physical KASLR, 所以获取了内核物理地址任意读写原语之后进行了全局物理地址的搜寻
8.  以 2MiB 为单位查找内核代码段地址 (这里是因为 kaslr 随机偏移也是以此为单位)，判断是否是内核地址则是通过 vmlinux 来判断特征，寻找到内核代码段地址之后就可以继续寻找`modprobe_path`进行写入，这里推荐另外一个[博客](elink@e32K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6@1K9r3g2G2M7X3W2Q4x3X3g2A6L8#2)9J5c8X3u0D9L8$3N6Q4x3V1k6J5k6i4k6A6N6X3W2F1k6#2)9J5k6s2c8Z5k6g2)9J5k6r3#2G2k6s2m8J5L8$3u0W2i4K6u0V1M7r3q4@1K9q4)9J5k6s2c8W2j5$3S2F1K9i4q4#2k6g2)9J5k6r3!0$3k6i4u0U0L8$3#2A6L8X3N6Q4x3X3c8K6k6h3q4J5j5$3S2Q4x3X3c8T1K9h3&6S2M7Y4W2Q4x3X3c8Z5j5h3&6V1L8r3g2J5i4K6u0V1M7r3q4@1j5$3R3`.)，这是在当前常规的`modprobe_path`利用手法失效的情况下重新寻找到的攻击链条，但是本博客由于依旧是老版本，则还是用的古早的利用方式，也就是执行`\xff\xff\xff\xff`开头的 shell 脚本

页表标识
====

```
~ PT Entry ~                                                    Present ──────┐
                                                            Read/Write ──────┐|
                                                      User/Supervisor ──────┐||
                                                  Page Write Through ──────┐|||
                                               Page Cache Disabled ──────┐ ||||
                                                         Accessed ──────┐| ||||
┌─── NX                                                    Dirty ──────┐|| ||||
|┌───┬─ Memory Protection Key              Page Attribute Table ──────┐||| ||||
||   |┌──────┬─── Ignored                               Global ─────┐ |||| ||||
||   ||      | ┌─── Reserved                          Ignored ───┬─┐| |||| ||||
||   ||      | |┌──────────────────────────────────────────────┐ | || |||| ||||
||   ||      | ||            4KB Page Physical Address         | | || |||| ||||
||   ||      | ||                                              | | || |||| ||||
XXXX XXXX XXXX 0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX
       56        48        40        32        24        16         8         0
```

引用
==

[https://pwning.tech/nftables/](elink@84cK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3N6$3&6A6L8X3N6Q4x3X3g2@1k6h3y4Z5i4K6u0r3L8X3k6@1j5h3u0D9k6i4y4Q4x3V1j5`.)  
[https://bsauce.github.io/2024/05/10/CVE-2024-1086/#2-3-ip%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87](elink@da0K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6T1M7$3q4#2j5$3g2Q4x3X3g2Y4K9i4c8Z5N6h3u0Q4x3X3g2A6L8#2)9J5c8U0t1H3x3U0c8Q4x3V1j5H3y4g2)9J5c8U0p5H3i4K6u0r3b7#2k6q4i4K6u0V1x3U0l9J5y4q4)9J5k6o6p5H3z5o6k6Q4x3V1k6Q4x3U0x3J5i4K6u0V1x3#2)9J5k6r3W2H3i4K6t1#2c8e0k6Q4x3U0f1&6y4g2)9J5y4f1t1H3i4K6t1#2c8e0k6Q4x3U0f1^5c8q4)9J5y4f1q4q4i4K6t1#2c8e0g2Q4x3U0f1^5b7#2)9J5y4e0R3#2i4K6t1#2c8e0g2Q4x3U0f1^5z5q4)9J5y4e0R3$3i4K6t1#2c8e0N6Q4x3U0f1^5z5g2)9J5y4e0R3%4)  
[https://packetpushers.net/blog/ip-fragmentation-in-detail/](elink@59cK9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6H3j5h3y4C8k6i4c8H3N6i4y4Z5k6i4u0K6i4K6u0W2L8X3g2@1i4K6u0r3j5X3I4G2k6#2)9J5c8X3W2H3i4K6u0V1k6Y4u0S2k6$3#2W2L8Y4c8S2N6r3W2G2L8W2)9J5k6r3W2F1i4K6u0V1k6r3g2@1j5h3W2D9i4K6u0r3)  
[https://en.wikipedia.org/wiki/Translation_lookaside_buffer](elink@0b1K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6W2L8W2)9J5k6i4N6A6K9$3W2H3k6h3c8A6j5g2)9J5k6h3!0J5k6#2)9J5c8Y4N6A6K9$3W2Q4x3V1k6f1M7X3q4F1M7$3I4S2N6r3W2G2L8W2)9#2k6X3I4G2L8$3E0S2M7$3W2V1k6g2)9#2k6X3u0#2k6X3k6W2M7R3`.`.)  
[https://theori.io/blog/reviving-the-modprobe-path-technique-overcoming-search-binary-handler-patch](elink@c29K9s2c8@1M7s2y4Q4x3@1q4Q4x3V1k6Q4x3V1k6@1K9r3g2G2M7X3W2Q4x3X3g2A6L8#2)9J5c8X3u0D9L8$3N6Q4x3V1k6J5k6i4k6A6N6X3W2F1k6#2)9J5k6s2c8Z5k6g2)9J5k6r3#2G2k6s2m8J5L8$3u0W2i4K6u0V1M7r3q4@1K9q4)9J5k6s2c8W2j5$3S2F1K9i4q4#2k6g2)9J5k6r3!0$3k6i4u0U0L8$3#2A6L8X3N6Q4x3X3c8K6k6h3q4J5j5$3S2Q4x3X3c8T1K9h3&6S2M7Y4W2Q4x3X3c8Z5j5h3&6V1L8r3g2J5i4K6u0V1M7r3q4@1j5$3R3`.)

[[培训] 内核驱动高级班，冲击 BAT 一流互联网大厂工作，每周日 13:00-18:00 直播授课](https://www.kanxue.com/book-section_list-173.htm)

[#漏洞分析](forum-150-1-153.htm) [#漏洞利用](forum-150-1-154.htm) [#UAF](forum-150-1-158.htm) [#Linux](forum-150-1-161.htm)